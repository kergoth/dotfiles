'use strict';

var tag = require('tagged-template-literals');
var trimNewLines = require('trim-newlines');

var indentionRegex = /^\s+/;
var allEmpty = /^\s+$/;

function trim(strings) {
  var subject = void 0;
  var indent = 0;

  for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }

  if (Array.isArray(strings)) {
    subject = tag(strings, values);
  } else if (typeof strings === 'string') {
    subject = strings;
    if (typeof values[0] === 'number') {
      indent = values[0];
    }
  } else {
    throw new Error('Invalid string provided');
  }

  var prepend = ' '.repeat(indent);
  var toReturn = [];
  var chunks = subject.split(/\r\n|\n/g);
  var leastIndention = Infinity;

  // Detect indention
  for (var i = 0; i < chunks.length; ++i) {
    var chunk = chunks[i];
    var match = chunk.match(indentionRegex);
    var indention = match ? match[0].length : 0;
    if (chunk.length && indention < leastIndention && !allEmpty.test(chunk)) {
      leastIndention = indention;
    }
  }

  if (leastIndention !== Infinity) {
    for (var _i = 0; _i < chunks.length; ++_i) {
      var _chunk = chunks[_i].substr(leastIndention);
      toReturn.push(_chunk.length ? prepend + _chunk : _chunk);
    }
  } else {
    for (var _i2 = 0; _i2 < chunks.length; ++_i2) {
      var _chunk2 = chunks[_i2];
      toReturn.push(_chunk2.length ? prepend + _chunk2 : _chunk2);
    }
  }

  return trimNewLines(toReturn.join('\n'));
}

module.exports = trim;