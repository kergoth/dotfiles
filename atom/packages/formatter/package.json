{
  "_args": [
    [
      {
        "raw": "/private/var/folders/dc/08bztltx53v8vk2hf180zqxw0000gn/T/d-118310-10186-szbrut.vcnds1nhfr/package.tgz",
        "scope": null,
        "escapedName": null,
        "name": null,
        "rawSpec": "/private/var/folders/dc/08bztltx53v8vk2hf180zqxw0000gn/T/d-118310-10186-szbrut.vcnds1nhfr/package.tgz",
        "spec": "/private/var/folders/dc/08bztltx53v8vk2hf180zqxw0000gn/T/d-118310-10186-szbrut.vcnds1nhfr/package.tgz",
        "type": "local"
      },
      "/private/var/folders/dc/08bztltx53v8vk2hf180zqxw0000gn/T/apm-install-dir-118310-10186-162dedz.r7ixef80k9"
    ]
  ],
  "_from": "../d-118310-10186-szbrut.vcnds1nhfr/package.tgz",
  "_id": "formatter@2.12.4",
  "_inCache": true,
  "_location": "/formatter",
  "_phantomChildren": {},
  "_requested": {
    "raw": "/private/var/folders/dc/08bztltx53v8vk2hf180zqxw0000gn/T/d-118310-10186-szbrut.vcnds1nhfr/package.tgz",
    "scope": null,
    "escapedName": null,
    "name": null,
    "rawSpec": "/private/var/folders/dc/08bztltx53v8vk2hf180zqxw0000gn/T/d-118310-10186-szbrut.vcnds1nhfr/package.tgz",
    "spec": "/private/var/folders/dc/08bztltx53v8vk2hf180zqxw0000gn/T/d-118310-10186-szbrut.vcnds1nhfr/package.tgz",
    "type": "local"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "file:../d-118310-10186-szbrut.vcnds1nhfr/package.tgz",
  "_shasum": "16e42f5f0e686592fc04baab9c253b85f3870802",
  "_shrinkwrap": null,
  "_spec": "/private/var/folders/dc/08bztltx53v8vk2hf180zqxw0000gn/T/d-118310-10186-szbrut.vcnds1nhfr/package.tgz",
  "_where": "/private/var/folders/dc/08bztltx53v8vk2hf180zqxw0000gn/T/apm-install-dir-118310-10186-162dedz.r7ixef80k9",
  "bugs": {
    "url": "https://github.com/atom-community/formatter/issues"
  },
  "consumedServices": {
    "formatter": {
      "versions": {
        "1.0.0": "consumeFormatter"
      }
    }
  },
  "dependencies": {
    "atom-slick": "^2.0.0",
    "clear-cut": "^0.4.0",
    "fuzzaldrin": "^2.1.0",
    "grim": "^1.2.0",
    "minimatch": "^2.0.1",
    "selector-kit": "^0.1",
    "semver": "^4.3.1",
    "stable": "^0.1.5",
    "underscore-plus": "^1.6.6"
  },
  "description": "Format your files automatically on save or on-demand by running commands.",
  "devDependencies": {
    "babel-eslint": "^5.0.0",
    "coffeelint": ">=1.8.1",
    "eslint": "^2.1.0",
    "eslint-config-standard": "^5.1.0",
    "eslint-plugin-promise": "^1.0.8",
    "eslint-plugin-standard": "^1.3.2",
    "fs-plus": "^2.4.0",
    "temp": "^0.8.3"
  },
  "engines": {
    "atom": ">=1.5.0 <2.0.0"
  },
  "homepage": "https://github.com/atom-community/formatter#readme",
  "license": "Apache-2.0",
  "main": "./lib/main",
  "name": "formatter",
  "optionalDependencies": {},
  "readme": "# `formatter` [![Build Status](https://travis-ci.org/atom-community/formatter.svg?branch=master)](https://travis-ci.org/atom-community/formatter) [![Build status](https://ci.appveyor.com/api/projects/status/p7o66o3jx9uxa1qd/branch/master?svg=true)](https://ci.appveyor.com/project/joefitzgerald/formatter/branch/master)\n\nThe core dependency you need to support formatting services.\n\nProvides a service API that you can register by scope name to send Async formatting edits.\n\n* Provides unified keyboard shortcuts\n* Takes care of command resolution to the correct scope and therefore provider\n* Takes care of applying the code edits in a manner that they can be easily undone (transactional)\n\n# Providers\n\n* [formatter-coffeescript](https://atom.io/packages/formatter-coffeescript)\n* [TypeScript](https://atom.io/packages/atom-typescript)\n\n# Keybindings\n\nDefault (inspired from IntelliJ):\n```cson\n'atom-text-editor':\n  'alt-ctrl-l': 'formatter:format-code'\n  'alt-cmd-l': 'formatter:format-code'\n```\n\n# API for Providers\n\nGiven you understand these simple concepts:\n```ts\n/** 0 based */\ninterface EditorPosition {\n    line: number;\n    col: number;\n}\n\ninterface CodeEdit {\n    start: EditorPosition;\n    end: EditorPosition;\n    newText: string;\n}\n\ninterface Selection {\n    start: EditorPosition;\n    end: EditorPosition;\n}\n```\n\nThe Provider really needs to be a `FormatterProvider`. It needs to provide a selector for which it will work. And then Either of the two:\n * a `getCodeEdits` function that gets passed in `FormattingOptions` and returns a bunch of `CodeEdit[]` or a promise thereof. This method is preferred as we do not create a `string`.\n * a `getNewText` function that gets passed in text and then returns\n formatted text. This is slower as we create and pass around strings.\n\n```ts\ninterface CodeEditOptions {\n    editor: AtomCore.IEditor;\n\n    // only if there is a selection\n    selection: Selection;\n}\n\ninterface FormatterProvider {\n    selector: string;\n    disableForSelector?: string;\n\n    // One of:\n    getCodeEdits: (options: CodeEditOptions) => CodeEdits[] | Promise<CodeEdit[]>;\n    getNewText: (oldText: string) => string | Promise<string>;\n}\n```\n\n\n## Sample Provider\n\n### **package.json**:\n\n```json\n\"providedServices\": {\n  \"formatter\": {\n    \"versions\": {\n      \"1.0.0\": \"provideFormatter\"\n    }\n  }\n}\n```\n\n### Providers:\n**Sample Coffeescript**\n```coffee\nmodule.exports = FormatterCoffeescript =\n  activate: (state) ->\n    return\n\n  provideFormatter: ->\n    {\n      selector: '.source.coffee',\n      getNewText: (text) =>\n        CF = require 'coffee-formatter'\n        lines = text.split('\\n');\n        resultArr = [];\n        for curr in lines\n          p = CF.formatTwoSpaceOperator(curr);\n          p = CF.formatOneSpaceOperator(p);\n          p = CF.shortenSpaces(p);\n          resultArr.push(p);\n        result = resultArr.join('\\n')\n        return result\n    }\n```\n\n**Sample TypeScript**\n\n```ts\nexport function provideFormatter() {\n    var formatter: FormatterProvider;\n    formatter = {\n        selector: '.source.ts',\n        getCodeEdits: (options: FormattingOptions): Promise<CodeEdit[]> => {\n            var filePath = options.editor.getPath();\n            if (!options.selection) {\n                return parent.formatDocument({ filePath: filePath }).then((result) => {\n                    return result.edits;\n                });\n            }\n            else {\n                return parent.formatDocumentRange({\n                  filePath: filePath,\n                  start: options.selection.start,\n                  end: options.selection.end })\n                    .then((result) => {\n                        return result.edits;\n                    });\n            }\n        }\n    };\n    return formatter;\n}\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/atom-community/formatter.git"
  },
  "version": "2.12.4"
}
