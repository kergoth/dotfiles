{"version":3,"sources":["../../../src/elements/types/Program.js"],"names":["Program","childNodes","_isProgram","_traverse","addElements","_eventListeners","plugins","children","isToken","passToken","skipNonCode","directives","isNode","push","passNode","body","isStatement","passStatement","assertEnd","type","selectNodesByType","selectTokensByType","elements","_emit","prependElements","removeElements","eventName","callback","filter","handler","data","handlers","i","length"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;;;;AACA;;;;;;IAEqBA,O;;;AACjB,qBAAYC,UAAZ,EAAoC;AAAA;;AAAA,4IAC1B,SAD0B,EACfA,UADe;;AAGhC,cAAKC,UAAL,GAAkB,IAAlB;AACA,cAAKC,SAAL,GAAiB,wBAAjB;AACA,cAAKA,SAAL,CAAeC,WAAf,CAA2BH,UAA3B;AACA,cAAKI,eAAL,GAAuB,EAAvB;AANgC;AAOnC;;;;uCAQcC,O,EAAsC;AACjD,iBAAKA,OAAL,GAAeA,OAAf;AACH;;;wCAEeC,Q,EAAyB;AACrC,gBAAIA,SAASC,OAAT,CAAiB,UAAjB,CAAJ,EAAkC;AAC9BD,yBAASE,SAAT,CAAmB,UAAnB;AACH;;AAEDF,qBAASG,WAAT;;AAEA,gBAAIC,aAAa,EAAjB;AACA,mBAAOJ,SAASK,MAAT,CAAgB,WAAhB,CAAP,EAAqC;AACjCD,2BAAWE,IAAX,CAAgBN,SAASO,QAAT,EAAhB;AACAP,yBAASG,WAAT;AACH;;AAED,gBAAIK,OAAO,EAAX;AACA,mBAAOR,SAASS,WAAT,EAAP,EAA+B;AAC3BD,qBAAKF,IAAL,CAAUN,SAASU,aAAT,EAAV;AACAV,yBAASG,WAAT;AACH;;AAEDH,qBAASE,SAAT,CAAmB,KAAnB;AACAF,qBAASW,SAAT;;AAEA,iBAAKH,IAAL,GAAYA,IAAZ;AACA,iBAAKJ,UAAL,GAAkBA,UAAlB;AACH;;AAED;;;;;;;;;0CAMkBQ,I,EAA2B;AACzC,mBAAO,KAAKhB,SAAL,CAAeiB,iBAAf,CAAiCD,IAAjC,CAAP;AACH;;AAED;;;;;;;;;2CAMmBA,I,EAA4B;AAC3C,mBAAO,KAAKhB,SAAL,CAAekB,kBAAf,CAAkCF,IAAlC,CAAP;AACH;;;8CAEqBG,Q,EAA0B;AAC5C,iBAAKnB,SAAL,CAAeC,WAAf,CAA2BkB,QAA3B;AACA,iBAAKC,KAAL,CAAW,cAAX,EAA2BD,QAA3B;AACH;;;kDAEyBA,Q,EAA0B;AAChD,iBAAKnB,SAAL,CAAeqB,eAAf,CAA+BF,QAA/B;AACA,iBAAKC,KAAL,CAAW,cAAX,EAA2BD,QAA3B;AACH;;;mDAE0BA,Q,EAA0B;AACjD,iBAAKnB,SAAL,CAAesB,cAAf,CAA8BH,QAA9B;AACA,iBAAKC,KAAL,CAAW,iBAAX,EAA8BD,QAA9B;AACH;;;2BAEEI,S,EAAmBC,Q,EAAoB;AACtC,gBAAI,KAAKtB,eAAL,CAAqBqB,SAArB,CAAJ,EAAqC;AACjC,qBAAKrB,eAAL,CAAqBqB,SAArB,EAAgCb,IAAhC,CAAqCc,QAArC;AACH,aAFD,MAEO;AACH,qBAAKtB,eAAL,CAAqBqB,SAArB,IAAkC,CAACC,QAAD,CAAlC;AACH;AACJ;;;4BAEGD,S,EAAmBC,Q,EAAoB;AACvC,gBAAI,KAAKtB,eAAL,CAAqBqB,SAArB,CAAJ,EAAqC;AACjC,qBAAKrB,eAAL,CAAqBqB,SAArB,IAAkC,KAAKrB,eAAL,CAAqBqB,SAArB,EAAgCE,MAAhC,CAAuC,UAACC,OAAD,EAAa;AAClF,2BAAOF,aAAaE,OAApB;AACH,iBAFiC,CAAlC;AAGH;AACJ;;;8BAEKH,S,EAAmBI,I,EAAW;AAChC,gBAAIC,WAAW,KAAK1B,eAAL,CAAqBqB,SAArB,CAAf;AACA,gBAAIK,QAAJ,EAAc;AACV,qBAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAID,SAASE,MAA7B,EAAqCD,GAArC,EAA0C;AACtCD,6BAASC,CAAT,EAAYF,IAAZ;AACH;AACJ;AACJ;;;;;kBAxGgB9B,O","file":"Program.js","sourcesContent":["/* @flow */\n\nimport type Token from '../Token';\nimport type Node from '../Node';\nimport type Element from '../Element';\nimport type ElementAssert from '../ElementAssert';\nimport type BasePlugin from '../../plugins/BasePlugin';\nimport Statement from '../Statement';\nimport Traverse from '../../Traverse';\n\nexport default class Program extends Statement {\n    constructor(childNodes: Array<any>) {\n        super('Program', childNodes);\n\n        this._isProgram = true;\n        this._traverse = new Traverse();\n        this._traverse.addElements(childNodes);\n        this._eventListeners = {};\n    }\n\n    _eventListeners: {[key: string]: Function[]};\n    _traverse: Traverse;\n    _body: Array<any>;\n    _isProgram: boolean;\n    plugins: {[key: string]: BasePlugin};\n\n    _acceptPlugins(plugins: {[key: string]: BasePlugin}) {\n        this.plugins = plugins;\n    }\n\n    _acceptChildren(children: ElementAssert) {\n        if (children.isToken('Hashbang')) {\n            children.passToken('Hashbang');\n        }\n\n        children.skipNonCode();\n\n        let directives = [];\n        while (children.isNode('Directive')) {\n            directives.push(children.passNode());\n            children.skipNonCode();\n        }\n\n        let body = [];\n        while (children.isStatement()) {\n            body.push(children.passStatement());\n            children.skipNonCode();\n        }\n\n        children.passToken('EOF');\n        children.assertEnd();\n\n        this.body = body;\n        this.directives = directives;\n    }\n\n    /**\n     * Returns node list with specified type from the tree.\n     *\n     * @param {String} type\n     * @returns {Node[]}\n     */\n    selectNodesByType(type: string): Array<Node> {\n        return this._traverse.selectNodesByType(type);\n    }\n\n    /**\n     * Returns tokens list with specified type from the tree.\n     *\n     * @param {String} type\n     * @returns {Token[]}\n     */\n    selectTokensByType(type: string): Array<Token> {\n        return this._traverse.selectTokensByType(type);\n    }\n\n    _addElementsToProgram(elements: Array<Element>) {\n        this._traverse.addElements(elements);\n        this._emit('elements-add', elements);\n    }\n\n    _prependElementsToProgram(elements: Array<Element>) {\n        this._traverse.prependElements(elements);\n        this._emit('elements-add', elements);\n    }\n\n    _removeElementsFromProgram(elements: Array<Element>) {\n        this._traverse.removeElements(elements);\n        this._emit('elements-remove', elements);\n    }\n\n    on(eventName: string, callback: Function) {\n        if (this._eventListeners[eventName]) {\n            this._eventListeners[eventName].push(callback);\n        } else {\n            this._eventListeners[eventName] = [callback];\n        }\n    }\n\n    off(eventName: string, callback: Function) {\n        if (this._eventListeners[eventName]) {\n            this._eventListeners[eventName] = this._eventListeners[eventName].filter((handler) => {\n                return callback !== handler;\n            });\n        }\n    }\n\n    _emit(eventName: string, data: any) {\n        let handlers = this._eventListeners[eventName];\n        if (handlers) {\n            for (let i = 0; i < handlers.length; i++) {\n                handlers[i](data);\n            }\n        }\n    }\n}\n"]}