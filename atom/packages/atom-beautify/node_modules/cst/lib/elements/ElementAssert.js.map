{"version":3,"sources":["../../src/elements/ElementAssert.js"],"names":["ElementAssert","elements","_elements","length","_navigate","tokenType","tokenValue","currentElement","isToken","type","value","Error","arguments","join","nodeType","isNode","nodeTypes","indexOf","isExpression","isAssignable","isPattern","isStatement","isModuleSpecifier","undefined","Boolean","assertToken","token","moveNext","assertNode","node","assertOneOfNode","_passExpressionInParens","expression","isWhitespace","assertCallback","openParens","skipNonCode","assertStatement","result","assertPattern","assertModuleSpecifier","isCode","getNewlineCount","_position","position","isEnd"],"mappings":"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","file":"ElementAssert.js","sourcesContent":["/* @flow */\n\nimport type Element from './Element';\n\n/**\n * Element assertion class.\n * Used in specific Node types to check children for syntax correctness.\n *\n */\nexport default class ElementAssert {\n    /**\n     * @param {Element[]} elements\n     */\n    constructor(elements: Array<Element>) {\n        this._elements = elements;\n\n        if (elements.length > 0) {\n            this._navigate(0);\n        }\n    }\n\n    _elements: Array<Element>;\n    currentElement: ?Element;\n    _position: number;\n\n    /**\n     * Asserts that the current element is a token.\n     * Can also check for token type and value.\n     *\n     * @param {String} [tokenType]\n     * @param {String|Object} [tokenValue] if object is given, checks if value of token exists as object key.\n     */\n    assertToken(tokenType: string, tokenValue: string | Object): void {\n        let {isToken, type, value} = this.currentElement || {};\n\n        if (!isToken) {\n            throw new Error(`Token expected but \"${type}\" found`);\n        }\n\n        if (arguments.length > 0 && type !== tokenType) {\n            throw new Error(`Expected token type \"${tokenType}\" but \"${type}\" found`);\n        }\n\n        if (arguments.length === 2) {\n            if (typeof tokenValue === 'object' && tokenValue !== null) {\n                if (!tokenValue[value]) {\n                    throw new Error(`Expected token value (${Object.keys(tokenValue).join(', ')}) but ${value} found`);\n                }\n            } else if (tokenValue !== value) {\n                throw new Error(`Expected token value \"${tokenValue}\" but ${value} found`);\n            }\n        }\n    }\n\n    /**\n     * Asserts that the current element is a node.\n     * Can also check for node type.\n     *\n     * @param {String} nodeType\n     */\n    assertNode(nodeType: string): void {\n        let {isNode, type} = this.currentElement || {};\n\n        if (!isNode) {\n            throw new Error(`Node expected but \"${type}\" found`);\n        }\n\n        if (arguments.length > 0 && type !== nodeType) {\n            throw new Error(`Expected node type \"${nodeType}\" but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is a node.\n     * Can also check if any of the node type are satisfied.\n     *\n     * @param {Array} nodeTypes\n     */\n    assertOneOfNode(nodeTypes: Array<string>): void {\n        let {isNode, type} = this.currentElement || {};\n\n        if (!isNode) {\n            throw new Error(`Node expected but \"${type}\" found`);\n        }\n\n        if (arguments.length > 0 && nodeTypes.indexOf(type) === -1) {\n            throw new Error(`Expected one of node types \"${nodeTypes}\" but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is an expression.\n     */\n    assertExpression(): void {\n        let {isExpression, type} = this.currentElement || {};\n\n        if (!isExpression) {\n            throw new Error(`Expression expected but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is an assignment.\n     */\n    assertAssignable(): void {\n        let {isAssignable, type} = this.currentElement || {};\n\n        if (!isAssignable) {\n            throw new Error(`Expected assignable expression but ${type} found.`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is a pattern.\n     */\n    assertPattern(): void {\n        let {isPattern, type} = this.currentElement || {};\n\n        if (!isPattern) {\n            throw new Error(`Expected pattern but ${type} found.`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is a statement.\n     */\n    assertStatement(): void {\n        let {isStatement, type} = this.currentElement || {};\n\n        if (!isStatement) {\n            throw new Error(`Statement expected but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is a statement.\n     */\n    assertModuleSpecifier(): void {\n        let {isModuleSpecifier, type} = this.currentElement || {};\n\n        if (!isModuleSpecifier) {\n            throw new Error(`ModuleSpecifier expected but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Asserts that the end of child list was reached.\n     */\n    assertEnd(): void {\n        if (this.currentElement !== undefined) {\n            let {type} = this.currentElement || {};\n            throw new Error(`Expected end of node list but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Checks if the current element is a token.\n     * Can also check for token type and value.\n     *\n     * @param {String} [tokenType]\n     * @param {String|Object} [tokenValue] if object is given, checks if value of token exists as object key.\n     * @returns {Boolean}\n     */\n    isToken(tokenType: string, tokenValue?: string | Object): boolean {\n        let {isToken, type, value} = this.currentElement || {};\n\n        if (!isToken || (arguments.length > 0 && type !== tokenType)) {\n            return false;\n        }\n\n        if (arguments.length === 2) {\n            if (typeof tokenValue === 'object' && tokenValue !== null) {\n                return Boolean(tokenValue[value]);\n            }\n            return tokenValue === value;\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks if the current element is a node.\n     * Can also check for token type and value.\n     *\n     * @param {String} [nodeType]\n     * @returns {Boolean}\n     */\n    isNode(nodeType: string): boolean {\n        let {isNode, type} = this.currentElement || {};\n\n        return !(!isNode || (arguments.length > 0 && type !== nodeType));\n    }\n\n    /**\n     * Checks if the current element is a statement.\n     *\n     * @returns {Boolean}\n     */\n    isStatement(): boolean {\n        let {isStatement} = this.currentElement || {};\n\n        return isStatement;\n    }\n\n    /**\n     * Checks if current element is token (can also check type and value),\n     * returns current element and move pointer to the next element.\n     *\n     * @param {String} [tokenType]\n     * @param {String|Object} [tokenValue]\n     * @returns {Element|null}\n     */\n    passToken(tokenType: string, tokenValue?: string | Object): ?Element {\n        this.assertToken(...arguments);\n        let token = this.currentElement;\n        this.moveNext();\n        return token;\n    }\n\n    /**\n     * Checks if current element is a node (can also check type),\n     * returns current element and move pointer to the next element.\n     *\n     * @param {String} [nodeType]\n     * @returns {Element|null}\n     */\n    passNode(nodeType: string): ?Element {\n        this.assertNode(...arguments);\n        let node = this.currentElement;\n        this.moveNext();\n        return node;\n    }\n\n    /**\n     * Checks if current element is a node (can also check if any types are satisfied),\n     * returns current element and move pointer to the next element.\n     *\n     * @param {Array} [nodeTypes]\n     * @returns {Element|null}\n     */\n    passOneOfNode(nodeTypes: Array<string>): ?Element {\n        this.assertOneOfNode(nodeTypes);\n        let node = this.currentElement;\n        this.moveNext();\n        return node;\n    }\n\n    /**\n     * Checks if current element is an expression,\n     * returns current element and move pointer to the next element.\n     * Ignores parentheses.\n     *\n     * @returns {Element}\n     */\n    passExpression(): Element {\n        return this._passExpressionInParens((expression) => expression.isExpression);\n    }\n\n    /**\n     * Checks if current element is an expression or whitespace\n     * returns current element and move pointer to the next element.\n     * Ignores parentheses.\n     *\n     * @returns {Element}\n     */\n    passExpressionOrWhitespace(): Element {\n        return this._passExpressionInParens((expression) => expression.isExpression || expression.isWhitespace);\n    }\n\n    /**\n     * Checks if current element is an expression or super,\n     * returns current element and move pointer to the next element.\n     * Ignores parentheses.\n     *\n     * @returns {Element}\n     */\n    passExpressionOrSuper(): Element {\n        return this._passExpressionInParens((expression) => expression.isExpression || expression.type === 'Super');\n    }\n\n    /**\n     * Checks if current element is an expression or SpreadElement,\n     * returns current element and move pointer to the next element.\n     * Ignores parentheses.\n     *\n     * @returns {Element}\n     */\n    passExpressionOrSpreadElement(): Element {\n        return this._passExpressionInParens(\n            (expression) => expression.isExpression || expression.type === 'SpreadElement');\n    }\n\n    /**\n     * Passes expression ignoring parentheses, returns element and move pointer to the next element.\n     *\n     * @param {Function} assertCallback\n     * @returns {Element}\n     * @private\n     */\n    _passExpressionInParens(assertCallback: Function): Element {\n        let openParens = 0;\n\n        while (this.currentElement.type === 'Punctuator' && this.currentElement.value === '(') {\n            openParens++;\n            this.moveNext();\n            this.skipNonCode();\n        }\n\n        let expression = this.currentElement;\n\n        if (!expression) {\n            throw new Error('Could not match an expression');\n        }\n\n        if (!assertCallback(expression)) {\n            throw new Error(`Expression expected but \"${expression.type}\" found`);\n        }\n\n        this.moveNext();\n\n        while (openParens--) {\n            this.skipNonCode();\n            this.assertToken('Punctuator', ')');\n            this.moveNext();\n        }\n\n        return expression;\n    }\n\n    /**\n     * Checks if current element is an assignable, returns current element and move pointer to the next element.\n     * Ignores parentheses.\n     *\n     * @returns {Element}\n     */\n    passAssignable(): Element {\n        return this._passExpressionInParens((expression) => expression.isAssignable);\n    }\n\n    /**\n     * Checks if current element is a statement,\n     * returns current element and move pointer to the next element.\n     *\n     * @returns {Element}\n     */\n    passStatement(): Element {\n        this.assertStatement();\n        let result = this.currentElement;\n        this.moveNext();\n        if (!result) {\n            throw new Error('Could not match statement');\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current element is a pattern,\n     * returns current element and move pointer to the next element.\n     *\n     * @returns {Element|null}\n     */\n    passPattern(): Element {\n        this.assertPattern();\n        let result = this.currentElement;\n        this.moveNext();\n        if (!result) {\n            throw new Error('Could not match pattern');\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current element is a module specifier,\n     * returns current element and move pointer to the next element.\n     *\n     * @returns {Element|null}\n     */\n    passModuleSpecifier(): ?Element {\n        this.assertModuleSpecifier();\n        let result = this.currentElement;\n        this.moveNext();\n        return result;\n    }\n\n    /**\n     * Skips comments and whitespace.\n     */\n    skipNonCode() {\n        while (true) {\n            let {isCode} = this.currentElement || {};\n            if (isCode !== false) {\n                break;\n            }\n            this.moveNext();\n        }\n    }\n\n    /**\n     * Skips comments and whitespace on the same line.\n     */\n    skipSameLineNonCode() {\n        while (true) {\n            let {isCode} = this.currentElement || {};\n            if (isCode !== false) {\n                break;\n            }\n\n            if (this.currentElement && this.currentElement.getNewlineCount() > 0) {\n                break;\n            }\n\n            this.moveNext();\n        }\n    }\n\n    /**\n     * Skips a semicolon.\n     */\n    skipSemicolon() {\n        if (this.currentElement && this.currentElement.type === 'Punctuator' && this.currentElement.value === ';') {\n            this.moveNext();\n        }\n    }\n\n    /**\n     * Moves pointer (currentElement) to next element.\n     */\n    moveNext() {\n        this._navigate(this._position + 1);\n    }\n\n    /**\n     * Navigates to specified child position.\n     *\n     * @param {Number} position\n     * @private\n     */\n    _navigate(position: number) {\n        this._position = position;\n        this.currentElement = this._elements[position];\n        this.isEnd = this.currentElement === undefined;\n    }\n}\n"]}