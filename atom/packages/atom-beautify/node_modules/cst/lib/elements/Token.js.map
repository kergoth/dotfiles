{"version":3,"sources":["../../src/elements/Token.js"],"names":["Token","type","value","valueToSourceCode","token","sourceCode","_sourceCode","arguments","length","isComment","isWhitespace","isCode","_sourceCodeLength","_sourceCodeLines","isToken","isNonCodeToken","newChildren","Error","childElements","String"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;AACA;;;;IAEqBA,K;;;;;AACjB;;;;;;+BAMcC,I,EAAcC,K,EAAmB;AAC3C,mBAAO,IAAIF,KAAJ,CAAUC,IAAV,EAAgBC,KAAhB,EAAuBC,kBAAkBF,IAAlB,EAAwBC,KAAxB,CAAvB,CAAP;AACH;;AAED;;;;;;;;wCAKuBE,K,EAAiE;AACpF,mBAAO,IAAIJ,KAAJ,CAAUI,MAAMH,IAAhB,EAAsBG,MAAMF,KAA5B,EAAmCE,MAAMC,UAAzC,CAAP;AACH;;AAED;;;;;;;;AAKA,mBAAYJ,IAAZ,EAA0BC,KAA1B,EAAyCI,WAAzC,EAA8D;AAAA;;AAAA,wIACpDL,IADoD,EAC9C,EAD8C;;AAG1D,YAAIM,UAAUC,MAAV,KAAqB,CAAzB,EAA4B;AACxBF,0BAAcH,kBAAkBF,IAAlB,EAAwBC,KAAxB,CAAd;AACH;;AAED,YAAIO,YAAY,KAAhB;AACA,YAAIC,eAAe,KAAnB;AACA,YAAIC,SAAS,IAAb;AACA,gBAAQV,IAAR;AACI,iBAAK,aAAL;AACIQ,4BAAY,IAAZ;AACAE,yBAAS,KAAT;AACA;AACJ,iBAAK,cAAL;AACIF,4BAAY,IAAZ;AACAE,yBAAS,KAAT;AACA;AACJ,iBAAK,YAAL;AACID,+BAAe,IAAf;AACAC,yBAAS,KAAT;AACA;AACJ,iBAAK,+BAAL;AACA,iBAAK,eAAL;AACA,iBAAK,UAAL;AACIA,yBAAS,KAAT;AACA;AAjBR;AAmBA,cAAKT,KAAL,GAAaA,KAAb;AACA,cAAKI,WAAL,GAAmBA,WAAnB;AACA,cAAKM,iBAAL,GAAyBN,YAAYE,MAArC;AACA,cAAKK,gBAAL,GAAwB,qBAASP,WAAT,CAAxB;AACA,cAAKQ,OAAL,GAAe,IAAf;AACA,cAAKL,SAAL,GAAiBA,SAAjB;AACA,cAAKC,YAAL,GAAoBA,YAApB;AACA,cAAKC,MAAL,GAAcA,MAAd;AACA,cAAKI,cAAL,GAAsB,CAACJ,MAAvB;AArC0D;AAsC7D;;;;wCAUiC;AAC9B,mBAAO,IAAP;AACH;;;uCAEgC;AAC7B,mBAAO,IAAP;AACH;;;wCAEuB;AACpB,mBAAO,KAAKL,WAAZ;AACH;;;8CAE6B;AAC1B,mBAAO,KAAKM,iBAAZ;AACH;;;6CAEmC;AAChC,mBAAO,KAAKC,gBAAZ;AACH;;;0CAEyB;AACtB,mBAAO,KAAKA,gBAAL,CAAsBL,MAAtB,GAA+B,CAAtC;AACH;;;2CAEkB;AACf,mBAAO,wBAAY,KAAKN,KAAjB,CAAP;AACH;;;qCAEYc,W,EAA+B;AACxC,gBAAIA,YAAYR,MAAZ,GAAqB,CAAzB,EAA4B;AACxB,sBAAM,IAAIS,KAAJ,CAAU,wCAAV,CAAN;AACH;;AAED,iBAAKC,aAAL,GAAqBF,WAArB;AACH;;AAED;;;;;;;;uCAKsB;AAClB,mBAAO,IAAIhB,KAAJ,CAAU,KAAKC,IAAf,EAAqB,KAAKC,KAA1B,EAAiC,KAAKI,WAAtC,CAAP;AACH;;;;;kBApHgBN,K;;;AAuHrB,SAASG,iBAAT,CAA2BF,IAA3B,EAAyCC,KAAzC,EAA6D;AACzD,YAAQD,IAAR;AACI,aAAK,aAAL;AACI,mBAAO,OAAOC,KAAd;;AAEJ,aAAK,cAAL;AACI,mBAAO,OAAOA,KAAP,GAAe,IAAtB;;AAEJ,aAAK,mBAAL;AACI,mBAAOiB,OAAOjB,KAAP,CAAP;;AAEJ,aAAK,SAAL;AACA,aAAK,SAAL;AACA,aAAK,MAAL;AACI,mBAAOiB,OAAOjB,KAAP,CAAP;;AAEJ;AACI,mBAAOA,KAAP;AAhBR;AAkBH","file":"Token.js","sourcesContent":["/* @flow */\n\nimport Element from './Element';\nimport {getLines, getLineInfo} from '../utils/lines';\n\nexport default class Token extends Element {\n    /**\n     * Generic token constructor.\n     *\n     * @param {String} type\n     * @param {*} value\n     */\n    static create(type: string, value: any): Token {\n        return new Token(type, value, valueToSourceCode(type, value));\n    }\n\n    /**\n     * Creates new token using babel/acorn parser token.\n     *\n     * @param {{type: String, value: String, sourceCode: String}} token\n     */\n    static createFromToken(token: {type: string, value: string, sourceCode: string}): Token {\n        return new Token(token.type, token.value, token.sourceCode);\n    }\n\n    /**\n     * @param {String} type\n     * @param {String} value\n     * @param {String} _sourceCode private source code argument\n     */\n    constructor(type: string, value: string, _sourceCode: string) {\n        super(type, []);\n\n        if (arguments.length === 2) {\n            _sourceCode = valueToSourceCode(type, value);\n        }\n\n        let isComment = false;\n        let isWhitespace = false;\n        let isCode = true;\n        switch (type) {\n            case 'CommentLine':\n                isComment = true;\n                isCode = false;\n                break;\n            case 'CommentBlock':\n                isComment = true;\n                isCode = false;\n                break;\n            case 'Whitespace':\n                isWhitespace = true;\n                isCode = false;\n                break;\n            case 'AppleInstrumentationDirective':\n            case 'GritDirective':\n            case 'Hashbang':\n                isCode = false;\n                break;\n        }\n        this.value = value;\n        this._sourceCode = _sourceCode;\n        this._sourceCodeLength = _sourceCode.length;\n        this._sourceCodeLines = getLines(_sourceCode);\n        this.isToken = true;\n        this.isComment = isComment;\n        this.isWhitespace = isWhitespace;\n        this.isCode = isCode;\n        this.isNonCodeToken = !isCode;\n    }\n\n    value: string;\n    _sourceCode: string;\n    _sourceCodeLength: number;\n    _sourceCodeLines: Array<string>;\n    _isComment: boolean;\n    _isWhitespace: boolean;\n    _isCode: boolean;\n\n    getFirstToken(): ?Token | Element {\n        return this;\n    }\n\n    getLastToken(): ?Token | Element {\n        return this;\n    }\n\n    getSourceCode(): string {\n        return this._sourceCode;\n    }\n\n    getSourceCodeLength(): number {\n        return this._sourceCodeLength;\n    }\n\n    getSourceCodeLines(): Array<string> {\n        return this._sourceCodeLines;\n    }\n\n    getNewlineCount(): number {\n        return this._sourceCodeLines.length - 1;\n    }\n\n    getValueLineInfo() {\n        return getLineInfo(this.value);\n    }\n\n    _setChildren(newChildren: Array<any>): void {\n        if (newChildren.length > 0) {\n            throw new Error('Token nodes cannot contain child nodes');\n        }\n\n        this.childElements = newChildren;\n    }\n\n    /**\n     * Clones current Element structure.\n     *\n     * @returns {Element}\n     */\n    cloneElement(): Token {\n        return new Token(this.type, this.value, this._sourceCode);\n    }\n}\n\nfunction valueToSourceCode(type: string, value: any): string {\n    switch (type) {\n        case 'CommentLine':\n            return '//' + value;\n\n        case 'CommentBlock':\n            return '/*' + value + '*/';\n\n        case 'RegularExpression':\n            return String(value);\n\n        case 'Numeric':\n        case 'Boolean':\n        case 'Null':\n            return String(value);\n\n        default:\n            return value;\n    }\n}\n"]}