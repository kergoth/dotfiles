{"version":3,"sources":["../../src/elements/Element.js"],"names":["Element","type","children","firstChild","lastChild","parentElement","nextSibling","previousSibling","childElements","i","length","Error","_setChildren","isToken","isWhitespace","isCode","isComment","isNonCodeToken","isNode","isStatement","isPattern","isAssignable","isFragment","element","_isProgram","getFirstToken","getLastToken","token","getNextToken","getPreviousToken","counter","previous","_sourceCodeLength","getSourceCodeLength","prevToken","startColumn","startLine","lines","_sourceCodeLines","getNewlineCount","elementLines","getSourceCodeLines","endLine","endColumn","start","line","column","end","child","code","getSourceCode","count","concat","elementIndex","indexOf","splice","ownerProgram","getOwnerProgram","_removeElementsFromProgram","setParentElement","removeChild","newElement","newElements","_ensureCanAdoptFragment","_ensureCanAdopt","_addElementsToProgram","_prependElementsToProgram","referenceChild","index","childrenBefore","slice","childrenAfter","firstRefChild","lastRefChild","firstIndex","lastIndex","replacedChildren","replacedChild","removedChildren","removedChild","oldElement","replaceChildren","fragment","fragmentChild","newChildren","_acceptChildren","previousChild","clonedChildren","Array","cloneElement","objectToClone","constructor","ConcreteElement","_onSetParentElement"],"mappings":"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","file":"Element.js","sourcesContent":["/* @flow */\n\nimport type Program from './types/Program';\nimport {getLines} from '../utils/lines';\nimport ElementAssert from './ElementAssert';\n\nexport type Position = {\n    line: number,\n    column: number\n};\n\nexport type Location = {\n    start: Position,\n    end: Position\n};\n\nexport type Range = [\n    number,\n    number\n];\n\n/**\n * Base class for Node, Token and Fragment.\n *\n * @name Element\n * @class\n * @abstract\n */\nexport default class Element {\n    /**\n     * @param {String} type\n     * @param {Element[]} children\n     */\n    constructor(type: string, children: Array<Element>) {\n        this.type = type;\n\n        this.firstChild = null;\n        this.lastChild = null;\n        this.parentElement = null;\n        this.nextSibling = null;\n        this.previousSibling = null;\n        this.childElements = [];\n\n        if (children) {\n            for (let i = 0; i < children.length; i++) {\n                if (children[i].parentElement) {\n                    throw new Error('Cannot add element to several parents');\n                }\n            }\n            this._setChildren(children);\n        }\n\n        this.isToken = false;\n        this.isWhitespace = false;\n        this.isCode = true;\n        this.isComment = false;\n        this.isNonCodeToken = this.isComment || this.isWhitespace;\n        this.isNode = false;\n        this.isStatement = false;\n        this.isPattern = false;\n        this.isAssignable = false;\n        this.isFragment = false;\n    }\n\n    type: string;\n    firstChild: ?Element;\n    lastChild: ?Element;\n    parentElement: ?Element;\n    nextSibling: ?Element;\n    previousSibling: ?Element;\n    childElements: Array<Element>;\n    _onSetParentElement: ?((parentElement: ?Element) => void);\n\n    isModuleSpecifier: boolean;\n\n    // ==== Traversing =================================================================================================\n\n    /**\n     * Owner Program for this element or null if element does not have Program in its parent hierarchy.\n     *\n     * @returns {Program}\n     */\n    getOwnerProgram(): Program {\n        let element = this;\n        while (element && !element._isProgram) {\n            element = element.parentElement;\n        }\n        return ((element: any): Program);\n    }\n\n    getNextToken() {\n        let element = this;\n        while (element) {\n            if (element.nextSibling) {\n                return element.nextSibling.getFirstToken();\n            }\n\n            element = element.parentElement;\n        }\n\n        return null;\n    }\n\n    getPreviousToken() {\n        let element = this;\n        while (element) {\n            if (element.previousSibling) {\n                return element.previousSibling.getLastToken();\n            }\n\n            element = element.parentElement;\n        }\n\n        return null;\n    }\n\n    /**\n     * Next token (non-whitespace and non-comment). Null if token was not found.\n     *\n     * @returns {Element|null}\n     */\n    getNextCodeToken(): ?Element {\n        let token = this.getNextToken();\n        while (token && !token.isCode) {\n            token = token.getNextToken();\n        }\n        return token;\n    }\n\n    /**\n     * Previous token (non-whitespace and non-comment). Null if token was not found.\n     *\n     * @returns {Element|null}\n     */\n    getPreviousCodeToken(): ?Element {\n        let token = this.getPreviousToken();\n        while (token && !token.isCode) {\n            token = token.getPreviousToken();\n        }\n        return token;\n    }\n\n    /**\n     * Next non-whitespace token. Null if token was not found.\n     *\n     * @returns {Element|null}\n     */\n    getNextNonWhitespaceToken(): ?Element {\n        let token = this.getNextToken();\n        while (token && token.isWhitespace) {\n            token = token.getNextToken();\n        }\n        return token;\n    }\n\n    /**\n     * Previous non-whitespace token. Null if token was not found.\n     *\n     * @returns {Element|null}\n     */\n    getPreviousNonWhitespaceToken(): ?Element {\n        let token = this.getPreviousToken();\n        while (token && token.isWhitespace) {\n            token = token.getPreviousToken();\n        }\n        return token;\n    }\n\n    /**\n     * First token inside element child tree.\n     *\n     * @returns {Element|null}\n     */\n    getFirstToken(): ?Element {\n        let element = this.firstChild;\n        while (element && !element.isToken) {\n            element = element.firstChild;\n        }\n        return element;\n    }\n\n    /**\n     * Last token inside element child tree.\n     *\n     * @returns {Element|null}\n     */\n    getLastToken(): ?Element {\n        let element = this.lastChild;\n        while (element && !element.isToken) {\n            element = element.lastChild;\n        }\n        return element;\n    }\n\n    /**\n     * Calculates and returns Element range.\n     *\n     * @returns {Number[]}\n     */\n    getRange(): Range {\n        let counter = 0;\n\n        let previous = this.getPreviousToken();\n        while (previous) {\n            counter += previous._sourceCodeLength;\n            previous = previous.getPreviousToken();\n        }\n\n        return [counter, counter + this.getSourceCodeLength()];\n    }\n\n    /**\n     * Calculates and returns Element loc.\n     *\n     * @returns {Object}\n     */\n    getLoc(): Location {\n        let prevToken = this.getPreviousToken();\n        let startColumn = 0;\n        let startLine = 1;\n        while (prevToken) {\n            let lines = prevToken._sourceCodeLines;\n            startColumn += lines[lines.length - 1].length;\n            if (lines.length > 1) {\n                while (prevToken) {\n                    startLine += prevToken.getNewlineCount();\n                    prevToken = prevToken.getPreviousToken();\n                }\n                break;\n            }\n            prevToken = prevToken.getPreviousToken();\n        }\n\n        let elementLines = this.getSourceCodeLines();\n        let endLine = startLine + elementLines.length - 1;\n        let endColumn = elementLines[elementLines.length - 1].length;\n\n        if (startLine === endLine) {\n            endColumn += startColumn;\n        }\n\n        return {\n            start: {\n                line: startLine,\n                column: startColumn,\n            },\n            end: {\n                line: endLine,\n                column: endColumn,\n            },\n        };\n    }\n\n    // ==== Source Code ================================================================================================\n\n    /**\n     * Generated source code length.\n     *\n     * @returns {Number}\n     */\n    getSourceCodeLength(): number {\n        let length = 0;\n        let child = this.firstChild;\n        while (child) {\n            length += child.getSourceCodeLength();\n            child = child.nextSibling;\n        }\n        return length;\n    }\n\n    /**\n     * Generated source code.\n     *\n     * @returns {String}\n     */\n    getSourceCode(): string {\n        let code = '';\n        let child = this.firstChild;\n\n        while (child) {\n            code += child.getSourceCode();\n            child = child.nextSibling;\n        }\n        return code;\n    }\n\n    /**\n     * Generated source code lines.\n     *\n     * @returns {String[]}\n     */\n    getSourceCodeLines(): Array<string> {\n        return getLines(this.getSourceCode());\n    }\n\n    /**\n     * Generated source code line break count.\n     *\n     * @returns {Number}\n     */\n    getNewlineCount(): number {\n        let count = 0;\n        let child = this.firstChild;\n        while (child) {\n            count += child.getNewlineCount();\n            child = child.nextSibling;\n        }\n        return count;\n    }\n\n    // ==== Child Element Manipulation =================================================================================\n\n    /**\n     * Removes specified element from the element child list.\n     *\n     * @param {Element} element\n     *\n     * @returns {Element}\n     */\n    removeChild(element: Element): Element {\n        if (element.parentElement !== this) {\n            throw new Error('The element to be removed is not a child of this element.');\n        }\n\n        let children = this.childElements.concat();\n        let elementIndex = children.indexOf(element);\n        children.splice(elementIndex, 1);\n\n        this._setChildren(children);\n\n        let ownerProgram = this.getOwnerProgram();\n        if (ownerProgram) {\n            ownerProgram._removeElementsFromProgram([element]);\n        }\n\n        setParentElement(element, null);\n\n        return element;\n    }\n\n    /**\n     * Removes element.\n     */\n    remove() {\n        if (!this.parentElement) {\n            return;\n        }\n\n        this.parentElement.removeChild(this);\n    }\n\n    /**\n     * Appends specified element to the end of the child list.\n     * Accepts multiple nodes using `Fragment`.\n     *\n     * @param {Element} newElement\n     */\n    appendChild(newElement: Element) {\n        let children: Element[];\n        let newElements: Element[];\n        if (newElement.isFragment) {\n            this._ensureCanAdoptFragment(newElement);\n            newElements = newElement.childElements;\n            children = this.childElements.concat(newElement.childElements);\n        } else {\n            if (newElement.parentElement) {\n                throw new Error('Remove element before adding again');\n            }\n            this._ensureCanAdopt(newElement);\n            newElements = [newElement];\n            children = this.childElements.concat(newElement);\n        }\n\n        this._setChildren(children);\n\n        if (newElements) {\n            let ownerProgram = this.getOwnerProgram();\n            if (ownerProgram) {\n                ownerProgram._addElementsToProgram(newElements);\n            }\n        }\n    }\n\n    /**\n     * Prepends specified element to the beginning of the child list.\n     * Accepts multiple nodes using `Fragment`.\n     *\n     * @param {Element} newElement\n     */\n    prependChild(newElement: Element) {\n        let children: Element[];\n        let newElements: Element[];\n        if (newElement.isFragment) {\n            this._ensureCanAdoptFragment(newElement);\n            newElements = newElement.childElements;\n            children = newElement.childElements.concat(this.childElements);\n        } else {\n            if (newElement.parentElement) {\n                throw new Error('Remove element before adding again');\n            }\n            this._ensureCanAdopt(newElement);\n            newElements = [newElement];\n            children = [newElement].concat(this.childElements);\n        }\n\n        this._setChildren(children);\n\n        if (newElements) {\n            let ownerProgram = this.getOwnerProgram();\n            if (ownerProgram) {\n                ownerProgram._prependElementsToProgram(newElements);\n            }\n        }\n    }\n\n    /**\n     * Inserts specified element before specified reference child.\n     * Accepts multiple nodes using `Fragment`.\n     *\n     * @param {Element} newElement\n     * @param {Element} referenceChild\n     */\n    insertChildBefore(newElement: Element, referenceChild: Element) {\n        if (referenceChild.parentElement !== this) {\n            throw new Error('Invalid reference child');\n        }\n\n        let index = this.childElements.indexOf(referenceChild);\n        let childrenBefore = this.childElements.slice(0, index);\n        let childrenAfter = this.childElements.slice(index);\n\n        let children: Element[];\n        let newElements: Element[];\n        if (newElement.isFragment) {\n            this._ensureCanAdoptFragment(newElement);\n            newElements = newElement.childElements;\n            children = childrenBefore.concat(newElement.childElements, childrenAfter);\n        } else {\n            if (newElement.parentElement) {\n                throw new Error('Remove element before adding again');\n            }\n\n            this._ensureCanAdopt(newElement);\n            children = childrenBefore.concat(newElement, childrenAfter);\n            newElements = [newElement];\n        }\n\n        this._setChildren(children);\n\n        if (newElements) {\n            let ownerProgram = this.getOwnerProgram();\n            if (ownerProgram) {\n                ownerProgram._addElementsToProgram(newElements);\n            }\n        }\n    }\n\n    /**\n     * Replaces children from `firstRefChild` to `lastRefChild` with specified element.\n     * Accepts multiple replacement nodes using `Fragment`.\n     *\n     * @param {Element} newElement\n     * @param {Element} firstRefChild\n     * @param {Element} lastRefChild\n     */\n    replaceChildren(newElement: Element, firstRefChild: Element, lastRefChild: Element) {\n        if (!firstRefChild || firstRefChild.parentElement !== this) {\n            throw new Error('Invalid first reference child');\n        }\n\n        if (!lastRefChild || lastRefChild.parentElement !== this) {\n            throw new Error('Invalid last reference child');\n        }\n\n        let firstIndex = this.childElements.indexOf(firstRefChild);\n        let lastIndex = this.childElements.indexOf(lastRefChild);\n\n        if (firstIndex > lastIndex) {\n            throw new Error('Invalid reference children order');\n        }\n\n        let childrenBefore = this.childElements.slice(0, firstIndex);\n        let childrenAfter = this.childElements.slice(lastIndex + 1);\n        let replacedChildren = this.childElements.slice(firstIndex, lastIndex + 1);\n\n        let children: Element[];\n        let newElements: Element[];\n        if (newElement.isFragment) {\n            this._ensureCanAdoptFragment(newElement);\n            children = childrenBefore.concat(newElement.childElements, childrenAfter);\n            newElements = newElement.childElements;\n        } else {\n            if (newElement.parentElement) {\n                throw new Error('Remove element before adding again');\n            }\n\n            this._ensureCanAdopt(newElement);\n            children = childrenBefore.concat(newElement, childrenAfter);\n            newElements = [newElement];\n        }\n\n        this._setChildren(children);\n\n        let ownerProgram = this.getOwnerProgram();\n\n        if (ownerProgram) {\n            ownerProgram._removeElementsFromProgram(replacedChildren);\n        }\n\n        for (let i = 0; i < replacedChildren.length; i++) {\n            let replacedChild = replacedChildren[i];\n            replacedChild.previousSibling = null;\n            replacedChild.nextSibling = null;\n            setParentElement(replacedChild, null);\n        }\n\n        if (ownerProgram && newElements) {\n            ownerProgram._addElementsToProgram(newElements);\n        }\n    }\n\n    /**\n     * Removes children from `firstRefChild` to `lastRefChild` with specified element.\n     *\n     * @param {Element} firstRefChild\n     * @param {Element} lastRefChild\n     */\n    removeChildren(firstRefChild: Element, lastRefChild: Element) {\n        if (!firstRefChild || firstRefChild.parentElement !== this) {\n            throw new Error('Invalid first reference child');\n        }\n\n        if (!lastRefChild || lastRefChild.parentElement !== this) {\n            throw new Error('Invalid last reference child');\n        }\n\n        let firstIndex = this.childElements.indexOf(firstRefChild);\n        let lastIndex = this.childElements.indexOf(lastRefChild);\n\n        if (firstIndex > lastIndex) {\n            throw new Error('Invalid reference children order');\n        }\n\n        let children = this.childElements.slice(0, firstIndex).concat(this.childElements.slice(lastIndex + 1));\n        let removedChildren = this.childElements.slice(firstIndex, lastIndex + 1);\n\n        this._setChildren(children);\n\n        let ownerProgram = this.getOwnerProgram();\n\n        if (ownerProgram) {\n            ownerProgram._removeElementsFromProgram(removedChildren);\n        }\n\n        for (let i = 0; i < removedChildren.length; i++) {\n            let removedChild = removedChildren[i];\n            removedChild.previousSibling = null;\n            removedChild.nextSibling = null;\n            setParentElement(removedChild, null);\n        }\n    }\n\n    /**\n     * Replaces child with specified element.\n     * Accepts multiple replacement nodes using `Fragment`.\n     *\n     * @param {Element} newElement\n     * @param {Element} oldElement\n     */\n    replaceChild(newElement: Element, oldElement: Element) {\n        this.replaceChildren(newElement, oldElement, oldElement);\n    }\n\n    /**\n     * Returns array of child element from firstRefChild to lastRefChild (including reference children).\n     *\n     * @param {Element} firstRefChild\n     * @param {Element} lastRefChild\n     * @returns {Array}\n     */\n    getChildrenBetween(firstRefChild: Element, lastRefChild: Element): Array<Element> {\n        if (!firstRefChild || firstRefChild.parentElement !== this) {\n            throw new Error('Invalid first reference child');\n        }\n\n        if (!lastRefChild || lastRefChild.parentElement !== this) {\n            throw new Error('Invalid last reference child');\n        }\n\n        let firstIndex = this.childElements.indexOf(firstRefChild);\n        let lastIndex = this.childElements.indexOf(lastRefChild);\n\n        if (firstIndex > lastIndex) {\n            throw new Error('Invalid reference children order');\n        }\n\n        return this.childElements.slice(firstIndex, lastIndex + 1);\n    }\n\n    /**\n     * Makes sure specified child is not already one of the parents of this element.\n     * Throws error on failure.\n     *\n     * @param {Element} child\n     * @private\n     */\n    _ensureCanAdopt(child: Element) {\n        let element = this;\n        while (element) {\n            if (element === child) {\n                throw new Error('The new child element contains the parent.');\n            }\n            element = element.parentElement;\n        }\n    }\n\n    /**\n     * Calls _ensureCanAdopt for each fragment element.\n     *\n     * @param {Element} fragment\n     * @private\n     */\n    _ensureCanAdoptFragment(fragment: Element) {\n        let fragmentChild = fragment.firstChild;\n        while (fragmentChild) {\n            this._ensureCanAdopt(fragmentChild);\n            fragmentChild = fragmentChild.nextSibling;\n        }\n    }\n\n    /**\n     * Assigns new children. Runs element syntax assertions.\n     *\n     * @param {Element[]} newChildren\n     * @private\n     */\n    _setChildren(newChildren: Element[]) {\n        this._acceptChildren(new ElementAssert(newChildren));\n\n        if (newChildren.length > 0) {\n            let previousChild = newChildren[0];\n            this.firstChild = previousChild;\n            previousChild.previousSibling = null;\n            setParentElement(previousChild, this);\n            if (newChildren.length > 1) {\n                // TODO(flow): error with only `let child;`\n                let child = newChildren[1];\n                for (let i = 1; i < newChildren.length; i++) {\n                    child = newChildren[i];\n                    child.previousSibling = previousChild;\n                    setParentElement(child, this);\n                    previousChild.nextSibling = child;\n                    previousChild = child;\n                }\n                child.nextSibling = null;\n                this.lastChild = child;\n            } else {\n                previousChild.nextSibling = null;\n                this.lastChild = previousChild;\n            }\n        } else {\n            this.firstChild = this.lastChild = null;\n        }\n\n        this.childElements = newChildren;\n    }\n\n    /**\n     * Runs element syntax assertions. Should be implemented for every Node.\n     *\n     * @param {Object} children\n     * @abstract\n     */\n    _acceptChildren(children: ElementAssert): void {\n        // Override\n    }\n\n    /**\n     * Clones current Element structure.\n     *\n     * @returns {Element}\n     */\n    cloneElement(): Element {\n        let clonedChildren: Element[] = new Array(this.childElements.length);\n        for (let i = 0; i < clonedChildren.length; i++) {\n            clonedChildren[i] = this.childElements[i].cloneElement();\n        }\n        let objectToClone = ((this: any): ConcreteElement);\n        return new objectToClone.constructor(clonedChildren);\n    }\n}\n\n/**\n * Artificial class for correct flow behaviour.\n */\nclass ConcreteElement extends Element {\n    constructor(children: Element[]) {\n        super('ConcreteElement', children);\n    }\n}\n\nfunction setParentElement(element: Element, parentElement: ?Element) {\n    element.parentElement = parentElement;\n    if (element._onSetParentElement) {\n        element._onSetParentElement(parentElement);\n    }\n}\n"]}