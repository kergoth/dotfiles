{"version":3,"sources":["../src/elementTree.js"],"names":["buildElementTree","buildTokenList","babylon","ast","tokens","firstToken","start","end","length","buildElementTreeItem","token","pos","state","elementType","type","childProps","value","key","error","SyntaxError","loc","childElements","i","childAst","Array","isArray","j","sort","ast1","ast2","NodeClass","Error","children","childElementIndex","childElement","EmptyNodeClass","endOfAstReached","addedTokenType","createFromToken","codeTokens","code","prevPos","result","processToken","substring","sourceCode","tt","tokTypes","source","name","semi","comma","parenL","parenR","braceL","braceR","slash","dot","bracketL","bracketR","ellipsis","arrow","star","incDec","colon","question","backQuote","dollarBraceL","at","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","exponent","prefix","doubleColon","isAssign","label","template","jsxTagStart","jsxTagEnd","jsxName","jsxText","keyword","num","string","regexp","eof","slice"],"mappings":"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","file":"elementTree.js","sourcesContent":["/* @flow */\n\nimport * as babylon from 'babylon';\n\nimport type Program from './elements/types/Program';\nimport type Location from './elements/Element';\n\nimport visitorKeys from './visitorKeys';\nimport elementIndex from './elements/elementIndex';\nimport Token from './elements/Token';\n\nexport type BabylonToken = {\n    type: string,\n    value: string,\n    start: number,\n    end: number,\n    loc?: Location,\n    sourceCode: string\n};\n\n/**\n * Creates CST using AST and token list.\n *\n * @param {Object} ast\n * @param {Array} tokens\n * @returns {Program}\n */\nexport function buildElementTree(ast: Object, tokens: Array<BabylonToken>): Program {\n    let firstToken = tokens[0];\n    ast.start = firstToken.start;\n    ast.end = tokens[tokens.length - 1].end;\n    return ((buildElementTreeItem(ast, {\n        tokens,\n        token: firstToken,\n        pos: 0,\n    }): any): Program);\n}\n\ntype ElementTreeItemState = {\n    tokens: Array<BabylonToken>,\n    token: BabylonToken,\n    pos: number\n};\n\n/**\n * @param {Object} ast\n * @param {{tokens: Array, token: Object, pos: Number}} state\n * @returns {Element}\n */\nfunction buildElementTreeItem(ast: Object, state: ElementTreeItemState): ?Element {\n    let elementType = ast.type;\n    let childProps = visitorKeys[elementType];\n\n    // Skip first `Identifier` for ({ test = 1 } = {})\n    // since it is already used in `AssignmentPattern`\n    // Need to fix this one day (See https://github.com/babel/babylon/issues/49)\n    if (\n        ast.type === 'ObjectProperty' &&\n        ast.value.type === 'AssignmentPattern'\n    ) {\n        delete ast.key;\n    }\n\n    if (!childProps) {\n        let error = new SyntaxError(`Cannot iterate using ${elementType}`);\n        error.loc = ast.loc.start;\n        throw error;\n    }\n\n    let childElements = [];\n    for (let i = 0; i < childProps.length; i++) {\n        let childAst = ast[childProps[i]];\n\n        if (!childAst) {\n            continue;\n        }\n\n        if (Array.isArray(childAst)) {\n            for (let j = 0; j < childAst.length; j++) {\n                if (childAst[j] === null) {\n                    continue;\n                }\n\n                childElements[childElements.length] = childAst[j];\n            }\n        } else {\n            childElements[childElements.length] = childAst;\n        }\n    }\n\n    childElements.sort((ast1, ast2) => {\n        return ast1.start < ast2.start ? -1 : (ast1.start > ast2.start ? 1 : 0);\n    });\n\n    let NodeClass = elementIndex[elementType];\n\n    if (!NodeClass) {\n        throw new Error(`Cannot create ${elementType} instance`);\n    }\n\n    let children = [];\n    let childElementIndex = 0;\n    let childElement = childElements[0];\n    let end = ast.end;\n\n    do {\n        if (childElement && state.token.start === childElement.start) {\n            if (state.token.end > childElement.end) {\n                let EmptyNodeClass = elementIndex[childElement.type];\n                if (!EmptyNodeClass) {\n                    throw new Error(`Cannot create ${childElement.type} instance`);\n                }\n\n                children[children.length] = new EmptyNodeClass([]);\n                childElement = childElements[++childElementIndex];\n            } else {\n                children[children.length] = buildElementTreeItem(childElement, state);\n                childElement = childElements[++childElementIndex];\n\n                if (!state.token ||\n                    (state.token.start === end && (state.token.end !== end || elementType !== 'Program'))\n                ) {\n                    return new NodeClass(children);\n                }\n            }\n        } else {\n            let endOfAstReached = state.token.end === end;\n            let addedTokenType = state.token.type;\n\n            if (endOfAstReached && ast.type === 'Identifier' && addedTokenType === 'Keyword') {\n                state.token.type = addedTokenType = 'Identifier';\n            }\n\n            children[children.length] = Token.createFromToken(state.token);\n\n            state.pos++;\n            state.token = state.tokens[state.pos];\n\n            if (elementType === 'Program' && addedTokenType !== 'EOF') {\n                continue;\n            }\n\n            if (endOfAstReached) {\n                return new NodeClass(children);\n            }\n        }\n    } while (state.token);\n}\n\n/**\n * Build single token list using code tokens, comments and whitespace.\n *\n * @param {Array} codeTokens\n * @param {String} code\n * @returns {Array}\n */\nexport function buildTokenList(codeTokens: Array<BabylonToken>, code: string): Array<BabylonToken> {\n    let prevPos = 0;\n    let result = [];\n\n    for (let i = 0; i < codeTokens.length; i++) {\n        let token = processToken(codeTokens[i], code);\n\n        let pos = token.start;\n        if (prevPos !== pos) {\n            let value = code.substring(prevPos, pos);\n            result[result.length] = {\n                type: 'Whitespace',\n                value,\n                sourceCode: value,\n                start: prevPos,\n                end: pos,\n            };\n        }\n        result[result.length] = token;\n\n        prevPos = token.end;\n    }\n\n    return result;\n}\n\n/**\n * Babylon token types.\n */\nlet tt = babylon.tokTypes;\n\n/**\n * Transforms Babylon-style token to Esprima-style token.\n *\n * @param {Object} token\n * @param {String} source\n */\nfunction processToken(token: Object, source: string): BabylonToken {\n    let type = token.type;\n\n    if (type === tt.name) {\n        token.type = 'Identifier';\n    } else if (type === tt.semi || type === tt.comma ||\n        type === tt.parenL || type === tt.parenR ||\n        type === tt.braceL || type === tt.braceR ||\n        type === tt.slash || type === tt.dot ||\n        type === tt.bracketL || type === tt.bracketR ||\n        type === tt.ellipsis || type === tt.arrow ||\n        type === tt.star || type === tt.incDec ||\n        type === tt.colon || type === tt.question ||\n        type === tt.backQuote ||\n        type === tt.dollarBraceL || type === tt.at ||\n        type === tt.logicalOR || type === tt.logicalAND ||\n        type === tt.bitwiseOR || type === tt.bitwiseXOR ||\n        type === tt.bitwiseAND || type === tt.equality ||\n        type === tt.relational || type === tt.bitShift ||\n        type === tt.plusMin || type === tt.modulo ||\n        type === tt.exponent || type === tt.prefix ||\n        type === tt.doubleColon ||\n        type.isAssign) {\n        token.type = 'Punctuator';\n        if (!token.value) {\n            token.sourceCode = token.value = type.label;\n        }\n    } else if (type === tt.template) {\n        token.type = 'Template';\n        token.sourceCode = token.value;\n    } else if (type === tt.jsxTagStart) {\n        token.type = 'Punctuator';\n        token.sourceCode = token.value = '<';\n    } else if (type === tt.jsxTagEnd) {\n        token.type = 'Punctuator';\n        token.sourceCode = token.value = '>';\n    } else if (type === tt.jsxName) {\n        token.type = 'JSXIdentifier';\n    } else if (type === tt.jsxText) {\n        token.type = 'JSXText';\n    } else if (type.keyword === 'null') {\n        token.type = 'Null';\n        token.value = null;\n    } else if (type.keyword === 'false' || type.keyword === 'true') {\n        token.type = 'Boolean';\n        token.value = type.keyword === 'true';\n    } else if (type.keyword) {\n        token.type = 'Keyword';\n    } else if (type === tt.num) {\n        token.type = 'Numeric';\n    } else if (type === tt.string) {\n        token.type = 'String';\n    } else if (type === tt.regexp) {\n        token.type = 'RegularExpression';\n    } else if (type === 'CommentLine') {\n        token.sourceCode = '//' + token.value;\n    } else if (type === 'CommentBlock') {\n        token.sourceCode = '/*' + token.value + '*/';\n    } else if (type === tt.eof) {\n        token.type = 'EOF';\n        token.sourceCode = token.value = '';\n    }\n\n    if (!('sourceCode' in token)) {\n        token.sourceCode = source.slice(token.start, token.end);\n    }\n\n    return token;\n}\n"]}