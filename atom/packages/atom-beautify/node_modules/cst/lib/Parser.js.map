{"version":3,"sources":["../src/Parser.js"],"names":["DIRECTIVE_APPLE_INSTRUMENTATION","type","regexp","DIRECTIVE_GRIT","Parser","options","_options","sourceType","strictMode","experimentalFeatures","languageExtensions","jsx","flow","plugins","setOptions","newOptions","currentOptions","currentExperimentalFeatures","currentLanguageExtensions","newExperimentalFeatures","newLanguageExtensions","code","ast","_parseAst","tokens","_processTokens","program","programPlugins","plugin","api","createApiForProgram","pluginName","getPluginName","Error","_acceptPlugins","directiveInstances","hasDirectives","directiveTypes","appleInstrumentationDirectives","push","gritDirectives","directive","replace","str","value","pos","slice","allowImportExportEverywhere","allowReturnOutsideFunction","allowSuperOutsideMethod","token","directiveInstance","start","substr"],"mappings":"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","file":"Parser.js","sourcesContent":["/* @flow */\n\nimport {parse} from 'babylon';\n\nimport type {BabylonToken} from './elementTree';\nimport type Program from './elements/types/Program';\nimport {buildTokenList, buildElementTree} from './elementTree';\nimport type BasePlugin from './plugins/BasePlugin';\n\n/**\n * @typedef {Object} CSTParserOptions\n * @property {String} sourceType Type of parsed code: \"module\" or \"script\".\n * @property {Boolean} allowReturnOutsideFunction\n * @property {Boolean} allowImportExportEverywhere\n * @property {Boolean} allowSuperOutsideMethod\n * @property {CSTParserExperimentalFeatureOptions} experimentalFeatures\n * @property {CSTParserLanguageExtensionsOptions} languageExtensions\n */\n\n/**\n * @typedef {Object} CSTParserLanguageExtensionsOptions\n * @property {Boolean} jsx\n * @property {Boolean} flow\n */\n\n/**\n * @typedef {Object} CSTParserExperimentalFeatureOptions\n * @property {Boolean} 'flow'\n * @property {Boolean} 'jsx'\n * @property {Boolean} 'asyncFunctions'\n * @property {Boolean} 'asyncGenerators'\n * @property {Boolean} 'classConstructorCall'\n * @property {Boolean} 'classProperties'\n * @property {Boolean} 'decorators'\n * @property {Boolean} 'doExpressions'\n * @property {Boolean} 'exponentiationOperator'\n * @property {Boolean} 'exportExtensions'\n * @property {Boolean} 'functionBind'\n * @property {Boolean} 'objectRestSpread'\n * @property {Boolean} 'trailingFunctionCommas\n */\n\n// https://developer.apple.com/library/watchos/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/UIAutomation.html\nconst DIRECTIVE_APPLE_INSTRUMENTATION = {\n    type: 'AppleInstrumentationDirective',\n    regexp: /^#([^\\n]+)/gm,\n};\n\n// https://www.chromium.org/developers/web-development-style-guide\nconst DIRECTIVE_GRIT = {\n    type: 'GritDirective',\n    regexp: /^\\s*<(\\/?\\s*(?:if|include)(?!\\w)[^]*?)>/gim,\n};\n\n// checking for the options passed to the babel parse method\nexport type CSTParserOptions = {\n    sourceType: 'script' | 'module',\n    allowReturnOutsideFunction: boolean,\n    allowImportExportEverywhere: boolean,\n    allowSuperOutsideMethod: boolean,\n    languageExtensions: Object,\n    experimentalFeatures: Object,\n    strictMode: ?boolean,\n    plugins: BasePlugin[]\n};\n\n/**\n * CST Parser.\n */\nexport default class Parser {\n    /**\n     * @param {CSTParserOptions} options\n     */\n    constructor(options?: CSTParserOptions) {\n        this._options = {\n            sourceType: 'module',\n            strictMode: true,\n            experimentalFeatures: {\n                'flow': true,\n                'jsx': true,\n                'asyncFunctions': true,\n                'asyncGenerators': true,\n                'classConstructorCall': true,\n                'classProperties': true,\n                'decorators': true,\n                'doExpressions': true,\n                'exponentiationOperator': true,\n                'exportExtensions': true,\n                'functionBind': true,\n                'objectRestSpread': true,\n                'trailingFunctionCommas': true,\n            },\n            languageExtensions: {\n                jsx: true,\n                flow: true,\n            },\n            plugins: [],\n        };\n\n        if (options) {\n            this.setOptions(options);\n        }\n    }\n\n    _options: CSTParserOptions;\n\n    /**\n     * @returns {CSTParserOptions}\n     */\n    getOptions(): CSTParserOptions {\n        return this._options;\n    }\n\n    /**\n     * @param {CSTParserOptions} newOptions\n     */\n    setOptions(newOptions: CSTParserOptions) {\n        let currentOptions = this._options;\n        let currentExperimentalFeatures = currentOptions.experimentalFeatures;\n        let currentLanguageExtensions = currentOptions.languageExtensions;\n        let newExperimentalFeatures = newOptions.experimentalFeatures;\n        let newLanguageExtensions = newOptions.languageExtensions;\n        this._options = {\n            ...currentOptions,\n            ...newOptions,\n            experimentalFeatures: {\n                ...currentExperimentalFeatures,\n                ...newExperimentalFeatures,\n            },\n            languageExtensions: {\n                ...currentLanguageExtensions,\n                ...newLanguageExtensions,\n            },\n        };\n    }\n\n    parse(code: string): Program {\n        let ast = this._parseAst(code);\n        let tokens = this._processTokens(ast, code);\n        let program = buildElementTree(ast, tokens);\n        let programPlugins = {};\n        let plugins = this._options.plugins;\n        for (let plugin of plugins) {\n            let api = plugin.createApiForProgram(program);\n            if (api) {\n                let pluginName = plugin.getPluginName();\n                if (pluginName in programPlugins) {\n                    throw new Error(`Plugin \"${pluginName}\" was already registered.`);\n                } else {\n                    programPlugins[pluginName] = api;\n                }\n            }\n        }\n\n        program._acceptPlugins(programPlugins);\n\n        return program;\n    }\n\n    _parseAst(code: string): Program {\n        let options = this._options;\n        let languageExtensions = options.languageExtensions;\n        let directiveInstances = {};\n        let hasDirectives = false;\n        let directiveTypes = [];\n\n        if (languageExtensions.appleInstrumentationDirectives) {\n            directiveTypes.push(DIRECTIVE_APPLE_INSTRUMENTATION);\n        }\n\n        if (languageExtensions.gritDirectives) {\n            directiveTypes.push(DIRECTIVE_GRIT);\n        }\n\n        for (let directive of directiveTypes) {\n            code = code.replace(directive.regexp, function(str, value, pos) {\n                hasDirectives = true;\n                directiveInstances[pos] = {\n                    type: directive.type, value,\n                };\n\n                // Cut 4 characters to save correct line/column info for surrounding code\n                return '/*' + str.slice(4) + '*/';\n            });\n        }\n\n        let ast = parse(code, {\n            sourceType: options.sourceType,\n            strictMode: options.strictMode,\n            allowImportExportEverywhere: options.allowImportExportEverywhere,\n            allowReturnOutsideFunction: options.allowReturnOutsideFunction,\n            allowSuperOutsideMethod: options.allowSuperOutsideMethod,\n            plugins: [\n                ...Object.keys(options.experimentalFeatures),\n                ...Object.keys(options.languageExtensions),\n            ],\n        });\n\n        let program = ast.program;\n        program.tokens = ast.tokens;\n\n        if (hasDirectives) {\n            for (let token of program.tokens) {\n                let directiveInstance = directiveInstances[token.start];\n                if (directiveInstances[token.start]) {\n                    token.type = directiveInstance.type;\n                    token.value = directiveInstance.value;\n                }\n            }\n        }\n\n        if (code.substr(0, 2) === '#!') {\n            program.tokens[0].type = 'Hashbang';\n        }\n\n        return program;\n    }\n\n    _processTokens(ast: Object, code: string): Array<BabylonToken> {\n        return buildTokenList(ast.tokens, code);\n    }\n}\n"]}