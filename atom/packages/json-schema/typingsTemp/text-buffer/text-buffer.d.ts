// Type definitions for text-buffer (v5.2.0)
// Project: https://github.com/atom/text-buffer
// Definitions by: david-driscoll <https://github.com/david-driscoll/>
// Definitions: https://github.com/borisyankov/DefinitelyTyped

// Generated by: https://github.com/david-driscoll/atom-typescript-generator
// Generation tool by david-driscoll <https://github.com/david-driscoll/>
/// <reference path="../serializable/serializable.d.ts" />
/// <reference path="../event-kit/event-kit.d.ts" />
/// <reference path="../../typings/q/Q.d.ts" />
declare module TextBuffer {
    /**
     * Represents a single change to {TextBuffer}. We reify the change into an object
     * so it can be stored in the undo/redo stack of {History}. 
     */
    class BufferPatch extends Serializable.Serializable {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        oldRange: Atom.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        newRange: Atom.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        oldText: string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        newText: string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        normalizeLineEndings: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        newMarkersSnapshot: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        oldMarkersSnapshot: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(oldRange? : Atom.Range, newRange? : Atom.Range, oldText? : string, newText? : string, normalizeLineEndings? : any, newMarkersSnapshot? : any, oldMarkersSnapshot? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        serializeParams() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deserializeParams(params? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        invert(buffer? : boolean) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        applyTo(buffer? : any) : any;
    
    }

    /**
     * Checkpoint
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class Checkpoint extends Serializable.Serializable {
    }

    /**
     * Manages undo/redo for {TextBuffer} 
     */
    class History extends Serializable.Serializable {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static version: number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buffer: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        undoStack: void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        redoStack: void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        currentTransaction: Transaction;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        transactionDepth: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        transactCallDepth: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(buffer? : any, undoStack? : any, redoStack? : any);
    
        /**
         * Used by {Serializable} during serialization 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        serializeParams() : any;
    
        /**
         * Used by {Serializable} during deserialization 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        deserializeParams(params? : any) : any;
    
        /**
         * Called by {TextBuffer} to store a patch in the undo stack. Clears the redo
         * stack 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        recordNewPatch(patch? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        undo() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        redo() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        transact(groupingInterval? : any, fn? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        beginTransaction(groupingInterval? : any) : Transaction;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        commitTransaction() : Transaction;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        abortTransaction() : Transaction;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        createCheckpoint() : Checkpoint;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        revertToCheckpoint(checkpoint? : Checkpoint) : Checkpoint;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        groupChangesSinceCheckpoint(checkpoint? : Checkpoint) : Checkpoint;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isTransacting() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        clearUndoStack() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        clearRedoStack() : void;
    
    }

    /**
     * Manages the markers for a buffer. 
     */
    class MarkerManager {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buffer: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        markers: Marker;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        nextMarkerId: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(buffer? : any, markers? : Marker);
    
        /**
         * Builds the ::intervals indexing structure, which allows for quick retrieval
         * based on location. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        buildIntervals() : any;
    
        /**
         * Called by {Serializable} during serialization 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        serializeParams() : any;
    
        /**
         * Called by {Serializable} during deserialization 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        deserializeParams(state? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        markRange(range? : Atom.Range, properties? : any) : Marker;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        markPosition(position? : Point, properties? : any) : Marker;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getMarker(id? : any) : Atom.Marker;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getMarkers() : Atom.Marker[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getMarkerCount() : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        findMarkers(params? : any) : Atom.Marker[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        createMarker(params? : any) : Atom.Marker;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        removeMarker(id? : any) : Atom.Marker;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        recordMarkerPatch(patch? : any) : MarkerPatch;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        handleBufferChange(patch? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildSnapshot() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        applySnapshot(snapshot? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pauseChangeEvents() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        resumeChangeEvents() : any;
    
    }

    /**
     * Represents changes to a {Marker}. These patches are thrown away for standalone
     * marker updates, but we reify marker changes into objects so they can be stored
     * within {Transaction}s. 
     */
    class MarkerPatch extends Serializable.Serializable {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        id: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        oldParams: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        newParams: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(id? : any, oldParams? : any, newParams? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        serializeParams() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deserializeParams(params? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        invert() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        applyTo(buffer? : any) : any;
    
    }

    /**
     * Represents a buffer annotation that remains logically stationary
     * even as the buffer changes. This is used to represent cursors, folds, snippet
     * targets, misspelled words, and anything else that needs to track a logical
     * location in the buffer over time.
     */
    class Marker {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static extractParams(inputParams? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static serializeSnapshot(snapshot? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static deserializeSnapshot(serializedSnapshot? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deferredChangeEvents: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(params? : any);
    
        /**
         * Used by {Serializable} during serialization. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        serializeParams() : any;
    
        /**
         * Used by {Serializable} during deserialization. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        deserializeParams(state? : any) : any;
    
        /**
         * Invoke the given callback when the marker is destroyed.
         * @param callback - {Function} to be called when the marker is destroyed.
         */
        onDidDestroy(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when the state of the marker changes.
         * @param callback - {Function} to be called when the marker changes.
         */
        onDidChange(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        getRange() : Atom.Range;
    
        /**
         * Sets the range of the marker.
         * @param range? - A {Range} or range-compatible {Array}. The range will be clipped before it is assigned.
         * @param properties? - {Object} properties to associate with the marker.
         */
        setRange(range? : Atom.Range, properties? : any) : Atom.Range;
    
        getHeadPosition() : Point;
    
        /**
         * Sets the head position of the marker.
         * @param position? - A {Point} or point-compatible {Array}. The position will be clipped before it is assigned.
         * @param properties? - {Object} properties to associate with the marker. 
         */
        setHeadPosition(position? : Point, properties? : any) : Point;
    
        getTailPosition() : Point;
    
        /**
         * Sets the head position of the marker. If the marker doesn't have a
         * tail, it will after calling this method.
         * @param position? - A {Point} or point-compatible {Array}. The position will be clipped before it is assigned.
         * @param properties? - {Object} properties to associate with the marker. 
         */
        setTailPosition(position? : Point, properties? : any) : Point;
    
        getStartPosition() : Point;
    
        getEndPosition() : Point;
    
        /**
         * Removes the marker's tail. After calling the marker's head position
         * will be reported as its current tail position until the tail is planted
         * again.
         * @param properties? - {Object} properties to associate with the marker. 
         */
        clearTail(properties? : any) : void;
    
        /**
         * Plants the marker's tail at the current head position. After calling
         * the marker's tail position will be its head position at the time of the
         * call, regardless of where the marker's head is moved.
         * @param properties? - {Object} properties to associate with the marker. 
         */
        plantTail(properties? : Object) : any;
    
        isReversed() : boolean;
    
        hasTail() : boolean;
    
        /**
         * Is the marker valid?
         */
        isValid() : boolean;
    
        /**
         * Is the marker destroyed?
         */
        isDestroyed() : boolean;
    
        isEqual(other? : boolean) : boolean;
    
        /**
         * Get the invalidation strategy for this marker.
         * 
         * Valid values include: `never`, `surround`, `overlap`, `inside`, and `touch`.
         * Returns a {String}.
         */
        getInvalidationStrategy() : string;
    
        getProperties() : Object;
    
        /**
         * Merges an {Object} containing new properties into the marker's
         * existing properties.
         * @param properties? - {Object} 
         */
        setProperties(properties? : any) : void;
    
        /**
         * Creates and returns a new {Marker} with the same properties as this
         * marker.
         * @param params? - {Object} 
         */
        copy(params? : Marker) : Marker;
    
        /**
         * Destroys the marker, causing it to emit the 'destroyed' event. Once
         * destroyed, a marker cannot be restored by undo/redo operations. 
         */
        destroy() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        extractParams(params? : any) : any;
    
        /**
         * Compares this marker to another based on their ranges.
         * @param other? - {Marker} 
         */
        compare(other? : Marker) : any;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
         * Returns whether this marker matches the given parameters. The parameters
         * are the same as {MarkerManager::findMarkers}.
         */
        matchesParams(params? : any) : any;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
         * Returns whether this marker matches the given parameter name and value.
         * The parameters are the same as {MarkerManager::findMarkers}.
         */
        matchesParam(key? : any, value? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        toParams(omitId? : any) : any;
    
        /**
         * Adjusts the marker's start and end positions and possibly its validity
         * based on the given {BufferPatch}. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        handleBufferChange(patch? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        update(options? : (range? : Atom.Range,reversed? : any,tailed? : any,valid? : any,properties? : any) => any, textChanged? : any) : void;
    
        /**
         * Updates the interval index on the marker manager with the marker's current
         * range. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        updateIntervals() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pauseChangeEvents() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        resumeChangeEvents() : any;
    
    }

    /**
     * Represents a point in a buffer in row/column coordinates.
     */
    class Point {
        /**
         * Convert any point-compatible object to a {Point}.
         * @param object? - This can be an object that's already a {Point}, in which case it's simply returned, or an array containing two {Number}s representing the row and column.
         * @param copy? - An optional boolean indicating whether to force the copying of objects that are already points.
         * Returns: A {Point} based on the given object.
         */
        static fromObject(object? : Point, copy? : any) : Point;
    
        static min(point1? : Point, point2? : Point) : Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        row: number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        column: number;
    
        /**
         * Construct a {Point} object
         * @param row? - {Number} row
         * @param column? - {Number} column 
         */
        constructor(row? : number, column? : number);
    
        copy() : Point;
    
        negate() : Point;
    
        /**
         * Makes this point immutable and returns itself.
         * Returns an immutable version of this {Point}
         */
        freeze() : Point;
    
        /**
         * Build and return a new point by adding the rows and columns of
         * the given point.
         * @param other? - A {Point} whose row and column will be added to this point's row and column to build the returned point.
         * Returns a {Point}.
         */
        translate(other? : Point) : Point;
    
        /**
         * Build and return a new {Point} by traversing the rows and columns
         * specified by the given point.
         * 
         * This method differs from the direct, vector-style addition offered by
         * {::translate}. Rather than adding the rows and columns directly, it derives
         * the new point from traversing in "typewriter space". At the end of every row
         * traversed, a carriage return occurs that returns the columns to 0 before
         * continuing the traversal.
         * @param other? - A {Point} providing the rows and columns to traverse by.
         * Returns a {Point}.
         */
        traverse(other? : Point) : Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        splitAt(column? : number) : any;
    
        compare(other? : Point) : any;
    
        isEqual(other? : boolean) : boolean;
    
        isLessThan(other? : boolean) : boolean;
    
        isLessThanOrEqual(other? : boolean) : boolean;
    
        isGreaterThan(other? : boolean) : boolean;
    
        isGreaterThanOrEqual(other? : boolean) : boolean;
    
        toArray() : any;
    
        serialize() : any;
    
        toString() : any;
    
    }

    /**
     * Represents a region in a buffer in row/column coordinates.
     */
    class Range {
        /**
         * Convert any range-compatible object to a {Range}.
         * @param object? - This can be an object that's already a {Range}, in which case it's simply returned, or an array containing two {Point}s or point-compatible arrays.
         * @param copy? - An optional boolean indicating whether to force the copying of objects that are already ranges.˚
         * Returns: A {Range} based on the given object.
         */
        static fromObject(object? : Range, copy? : any) : Range;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        static fromText(args? : any) : string;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
         * @param startPoint? - A {Point} or point-compatible {Array}
         * @param rowDelta? - A {Number} indicating how many rows to add to the start point to get the end point.
         * @param columnDelta? - A {Number} indicating how many rows to columns to the start point to get the end point. 
         * Returns a {Range} that starts at the given point and ends at the
         * start point plus the given row and column deltas.
         */
        static fromPointWithDelta(startPoint? : Point, rowDelta? : number, columnDelta? : number) : Range;
    
        /**
         * Call this with the result of {Range::serialize} to construct a new Range.
         * @param array? - {array} of params to pass to the {::constructor} 
         */
        static deserialize(array? : any[]) : any;
    
        /**
         * Construct a {Range} object
         */
        constructor(pointA? : any, pointB? : any);
    
        copy() : Range;
    
        negate() : any;
    
        serialize() : any;
    
        /**
         * Is the start position of this range equal to the end position?
         */
        isEmpty() : boolean;
    
        isSingleLine() : number;
    
        /**
         * Get the number of rows in this range.
         */
        getRowCount() : number;
    
        getRows() : number[];
    
        /**
         * Freezes the range and its start and end point so it becomes
         * immutable and returns itself.
         * Returns an immutable version of this {Range}
         */
        freeze() : Range;
    
        union(otherRange? : Atom.Range) : any;
    
        /**
         * Build and return a new range by translating this range's start and
         * end points by the given delta(s).
         * @param startDelta? - A {Point} by which to translate the start of this range.
         * @param endDelta? - A {Point} to by which to translate the end of this range. If omitted, the `startDelta` will be used instead.
         * Returns a {Range}.
         */
        translate(startDelta? : Point, endDelta? : Point) : Range;
    
        /**
         * Build and return a new range by traversing this range's start and
         * end points by the given delta.
         * 
         * See {Point::traverse} for details of how traversal differs from translation.
         * @param delta? - A {Point} containing the rows and columns to traverse to derive the new range.
         * Returns a {Range}.
         */
        traverse(delta? : Point) : Range;
    
        /**
         * Compare two Ranges
         * Returns `-1` if this range starts before the argument or contains it.
         * Returns `0` if this range is equivalent to the argument.
         * Returns `1` if this range starts after the argument or is contained by it.
         */
        compare(other? : any) : any;
    
        isEqual(other? : boolean) : boolean;
    
        coversSameRows(other? : any) : number[];
    
        /**
         * Determines whether this range intersects with the argument.
         * @param otherRange? - A {Range} or range-compatible {Array}
         * @param exclusive? - {Boolean} indicating whether to exclude endpoints   when testing for intersection. Defaults to `false`.
         */
        intersectsWith(otherRange? : Atom.Range, exclusive? : boolean) : boolean;
    
        containsRange(otherRange? : Atom.Range, exclusive? : any) : Atom.Range;
    
        containsPoint(point? : Point, exclusive? : any) : Point;
    
        intersectsRow(row? : number) : number;
    
        intersectsRowRange(startRow? : number, endRow? : number) : Atom.Range;
    
        /**
         * Conversion
         * This field or method was marked private by atomdoc. Use with caution.
         */
        toDelta() : any;
    
        toString() : any;
    
    }

    /**
     * A mutable text container with undo/redo support and the ability to
     * annotate logical regions in the text. 
     */
    class TextBuffer {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static Point: Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static Range: Atom.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static newlineRegex: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        cachedText: string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        encoding: string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        stoppedChangingDelay: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        stoppedChangingTimeout: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        cachedDiskContents: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        conflict: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        file: Pathwatcher.File;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        refcount: number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        fileSubscriptions: any /* default */;
    
        /**
         * Create a new buffer with the given params.
         * @param params? - {Object} or {String} of text
         */
        constructor(params? : Object);
    
        /**
         * Called by {Serializable} mixin during deserialization. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        deserializeParams(params? : any) : any;
    
        /**
         * Called by {Serializable} mixin during serialization. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        serializeParams() : any;
    
        /**
         * Invoke the given callback synchronously _before_ the content of the
         * buffer changes.
         * 
         * Because observers are invoked synchronously, it's important not to perform
         * any expensive operations via this method.
         * @param callback - {Function} to be called when the buffer changes.
         */
        onWillChange(callback : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback synchronously when the content of the
         * buffer changes.
         * 
         * Because observers are invoked synchronously, it's important not to perform
         * any expensive operations via this method. Consider {::onDidStopChanging} to
         * delay expensive operations until after changes stop occurring.
         * @param callback - {Function} to be called when the buffer changes.
         */
        onDidChange(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        preemptDidChange(callback? : any) : any;
    
        /**
         * Invoke the given callback asynchronously following one or more
         * changes after {::getStoppedChangingDelay} milliseconds elapse without an
         * additional change.
         * 
         * This method can be used to perform potentially expensive operations that
         * don't need to be performed synchronously. If you need to run your callback
         * synchronously, use {::onDidChange} instead.
         * @param callback - {Function} to be called when the buffer stops changing.
         */
        onDidStopChanging(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when the in-memory contents of the
         * buffer become in conflict with the contents of the file on disk.
         * @param callback - {Function} to be called when the buffer enters conflict.
         */
        onDidConflict(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        /**
         * Invoke the given callback the value of {::isModified} changes.
         * @param callback - {Function} to be called when {::isModified} changes.
         */
        onDidChangeModified(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when all marker `::onDidChange`
         * observers have been notified following a change to the buffer.
         * 
         * The order of events following a buffer change is as follows:
         * 
         * * The text of the buffer is changed
         * * All markers are updated accordingly, but their `::onDidChange` observers
         *   are not notified.
         * * `TextBuffer::onDidChange` observers are notified.
         * * `Marker::onDidChange` observers are notified.
         * * `TextBuffer::onDidUpdateMarkers` observers are notified.
         * 
         * Basically, this method gives you a way to take action after both a buffer
         * change and all associated marker changes.
         * @param callback - {Function} to be called after markers are updated.
         */
        onDidUpdateMarkers(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when a marker is created.
         * @param callback - {Function} to be called when a marker is created.
         */
        onDidCreateMarker(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when the value of {::getPath} changes.
         * @param callback - {Function} to be called when the path changes.
         */
        onDidChangePath(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when the value of {::getEncoding} changes.
         * @param callback - {Function} to be called when the encoding changes.
         */
        onDidChangeEncoding(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        /**
         * Invoke the given callback before the buffer is saved to disk.
         * @param callback - {Function} to be called before the buffer is saved.
         */
        onWillSave(callback : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback after the buffer is saved to disk.
         * @param callback - {Function} to be called after the buffer is saved.
         */
        onDidSave(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        /**
         * Invoke the given callback after the file backing the buffer is
         * deleted.
         * @param callback - {Function} to be called after the buffer is deleted.
         */
        onDidDelete(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        /**
         * Invoke the given callback before the buffer is reloaded from the
         * contents of its file on disk.
         * @param callback - {Function} to be called before the buffer is reloaded.
         */
        onWillReload(callback : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback after the buffer is reloaded from the
         * contents of its file on disk.
         * @param callback - {Function} to be called after the buffer is reloaded.
         */
        onDidReload(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when the buffer is destroyed.
         * @param callback - {Function} to be called when the buffer is destroyed.
         */
        onDidDestroy(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when there is an error in watching the
         * file.
         * @param callback - {Function} callback
         */
        onWillThrowWatchError(callback : Function) : EventKit.Disposable;
    
        /**
         * Get the number of milliseconds that will elapse without a change
         * before {::onDidStopChanging} observers are invoked following a change.
         * Returns a {Number}.
         */
        getStoppedChangingDelay() : number;
    
        /**
         * Determine if the in-memory contents of the buffer differ from its
         * contents on disk.
         * 
         * If the buffer is unsaved, always returns `true` unless the buffer is empty.
         */
        isModified() : boolean;
    
        /**
         * Determine if the in-memory contents of the buffer conflict with the
         * on-disk contents of its associated file.
         */
        isInConflict() : boolean;
    
        /**
         * Get the path of the associated file.
         */
        getPath() : string;
    
        /**
         * Set the path for the buffer's associated file.
         * @param filePath? - A {String} representing the new file path 
         */
        setPath(filePath? : string) : string;
    
        /**
         * Sets the character set encoding for this buffer.
         * @param encoding? - The {String} encoding to use (default: 'utf8'). 
         */
        setEncoding(encoding? : string) : string;
    
        getEncoding() : string;
    
        /**
         * Get the path of the associated file.
         */
        getUri() : string;
    
        /**
         * Get the basename of the associated file.
         * 
         * The basename is the name portion of the file's path, without the containing
         * directories.
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getBaseName() : string;
    
        /**
         * Determine whether the buffer is empty.
         */
        isEmpty() : boolean;
    
        /**
         * Get the entire text of the buffer.
         */
        getText() : string;
    
        /**
         * Get the text in a range.
         * @param range? - A {Range}
         */
        getTextInRange(range? : Atom.Range) : Atom.Range;
    
        /**
         * Get the text of all lines in the buffer, without their line endings.
         */
        getLines() : string[];
    
        /**
         * Get the text of the last line of the buffer, without its line
         * ending.
         */
        getLastLine() : number;
    
        /**
         * Get the text of the line at the given row, without its line ending.
         * @param row? - A {Number} representing a 0-indexed row.
         */
        lineForRow(row? : number) : number;
    
        /**
         * Get the line ending for the given 0-indexed row.
         * @param row? - A {Number} indicating the row.
         */
        lineEndingForRow(row? : number) : number;
    
        /**
         * Get the length of the line for the given 0-indexed row, without its
         * line ending.
         * @param row? - A {Number} indicating the row.
         */
        lineLengthForRow(row? : number) : number;
    
        /**
         * Determine if the given row contains only whitespace.
         * @param row? - A {Number} representing a 0-indexed row.
         */
        isRowBlank(row? : number) : boolean;
    
        /**
         * Given a row, find the first preceding row that's not blank.
         * @param startRow? - A {Number} identifying the row to start checking at.
         */
        previousNonBlankRow(startRow? : number) : number;
    
        /**
         * Given a row, find the next row that's not blank.
         * @param startRow? - A {Number} identifying the row to start checking at.
         */
        nextNonBlankRow(startRow? : number) : number;
    
        /**
         * Replace the entire contents of the buffer with the given text.
         * @param text? - A {String}
         */
        setText(text? : string) : string;
    
        /**
         * Replace the current buffer contents by applying a diff based on the
         * given text.
         * @param text? - A {String} containing the new buffer contents. 
         */
        setTextViaDiff(text? : string) : string;
    
        /**
         * Set the text in the given range.
         * @param range? - A {Range}
         * @param text? - A {String}
         * @param options? - {Object}
         */
        setTextInRange(range? : Atom.Range, text? : string, options? : any) : Atom.Range;
    
        /**
         * Insert text at the given position.
         * @param position? - A {Point} representing the insertion location. The position is clipped before insertion.
         * @param text? - A {String} representing the text to insert.
         * @param options? - {Object}
         */
        insert(position? : boolean, text? : string, options? : boolean) : Range | boolean;
    
        /**
         * Append text to the end of the buffer.
         * @param text? - A {String} representing the text text to append.
         * @param options? - {Object}
         * Returns the {Range} of the inserted text
         */
        append(text? : string, options? : Object) : Range;
    
        /**
         * Builds a {BufferPatch}, which is used to modify the buffer and is also
         * pushed into the undo history so it can be undone. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        buildPatch(oldRange? : Atom.Range, newText? : string, normalizeLineEndings? : any) : any;
    
        /**
         * Applies a {BufferPatch} to the buffer based on its old range and new text.
         * Also applies any {MarkerPatch}es associated with the {BufferPatch}. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        applyPatch(patch? : any) : any;
    
        /**
         * Delete the text in the given range.
         * @param range? - A {Range} in which to delete. The range is clipped before deleting.
         */
        delete(range? : Atom.Range) : void;
    
        /**
         * Delete the line associated with a specified row.
         * @param row? - A {Number} representing the 0-indexed row to delete.
         */
        deleteRow(row? : number) : number;
    
        /**
         * Delete the lines associated with the specified row range.
         * 
         * If the row range is out of bounds, it will be clipped. If the startRow is
         * greater than the end row, they will be reordered.
         * @param startRow? - A {Number} representing the first row to delete.
         * @param endRow? - A {Number} representing the last row to delete, inclusive.
         */
        deleteRows(startRow? : number, endRow? : number) : number[];
    
        /**
         * Create a marker with the given range. This marker will maintain
         * its logical location as the buffer is changed, so if you mark a particular
         * word, the marker will remain over that word even if the word's location in
         * the buffer changes.
         * @param range? - A {Range} or range-compatible {Array}
         * @param properties? - A hash of key-value pairs to associate with the marker. There are also reserved property names that have marker-specific meaning.
         */
        markRange(range? : Atom.Range, properties? : any) : Marker;
    
        /**
         * Create a marker at the given position with no tail.
         * @param position? - {Point} or point-compatible {Array}
         * @param properties? - This is the same as the `properties` parameter in {::markRange}
         */
        markPosition(position? : Point, properties? : any) : Marker;
    
        /**
         * Get all existing markers on the buffer.
         */
        getMarkers() : Atom.Marker[];
    
        /**
         * Get an existing marker by its id.
         * @param id? - {Number} id of the marker to retrieve
         */
        getMarker(id? : number) : Atom.Marker;
    
        /**
         * Find markers conforming to the given parameters.
         * 
         * Markers are sorted based on their position in the buffer. If two markers
         * start at the same position, the larger marker comes first.
         * @param params? - A hash of key-value pairs constraining the set of returned markers. You can query against custom marker properties by listing the desired key-value pairs here. In addition, the following keys are reserved and have special semantics:
         */
        findMarkers(params? : any) : Atom.Marker[];
    
        /**
         * Get the number of markers in the buffer.
         */
        getMarkerCount() : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroyMarker(id? : any) : Atom.Marker;
    
        /**
         * Undo the last operation. If a transaction is in progress, aborts it. 
         */
        undo() : void;
    
        /**
         * Redo the last operation 
         */
        redo() : void;
    
        /**
         * Batch multiple operations as a single undo/redo step.
         * 
         * Any group of operations that are logically grouped from the perspective of
         * undoing and redoing should be performed in a transaction. If you want to
         * abort the transaction, call {::abortTransaction} to terminate the function's
         * execution and revert any changes performed up to the abortion.
         * @param groupingInterval? - The {Number} of milliseconds for which this transaction should be considered 'open for grouping' after it begins. If a transaction with a positive `groupingInterval` is committed while the previous transaction is still open for grouping, the two transactions are merged with respect to undo and redo.
         * @param fn? - A {Function} to call inside the transaction. 
         */
        transact(groupingInterval? : number, fn? : Function) : any;
    
        /**
         * Clear the undo stack. 
         */
        clearUndoStack() : void;
    
        /**
         * Create a pointer to the current state of the buffer for use
         * with {::revertToCheckpoint} and {::groupChangesSinceCheckpoint}.
         */
        createCheckpoint() : Checkpoint;
    
        /**
         * Revert the buffer to the state it was in when the given
         * checkpoint was created.
         * 
         * The redo stack will be empty following this operation, so changes since the
         * checkpoint will be lost. If the given checkpoint is no longer present in the
         * undo history, no changes will be made to the buffer and this method will
         * return `false`.
         */
        revertToCheckpoint(checkpoint? : Checkpoint) : Checkpoint;
    
        /**
         * Group all changes since the given checkpoint into a single
         * transaction for purposes of undo/redo.
         * 
         * If the given checkpoint is no longer present in the undo history, no
         * grouping will be performed and this method will return `false`.
         */
        groupChangesSinceCheckpoint(checkpoint? : Checkpoint) : Checkpoint;
    
        /**
         * Scan regular expression matches in the entire buffer, calling the
         * given iterator function on each match.
         * 
         * If you're programmatically modifying the results, you may want to try
         * {::backwardsScan} to avoid tripping over your own changes.
         * @param regex? - A {RegExp} to search for.
         * @param iterator? - A {Function} that's called on each match with an {Object} containing the following keys:
         */
        scan(regex? : RegExp, iterator? : Function) : any;
    
        /**
         * Scan regular expression matches in the entire buffer in reverse
         * order, calling the given iterator function on each match.
         * @param regex? - A {RegExp} to search for.
         * @param iterator? - A {Function} that's called on each match with an {Object} containing the following keys:
         */
        backwardsScan(regex? : RegExp, iterator? : Function) : any;
    
        /**
         * Scan regular expression matches in a given range , calling the given
         * iterator function on each match.
         * @param regex? - A {RegExp} to search for.
         * @param range? - A {Range} in which to search.
         * @param iterator? - A {Function} that's called on each match with an {Object} containing the following keys:
         */
        scanInRange(regex? : RegExp, range? : Atom.Range, iterator? : Function, reverse? : any) : Atom.Range;
    
        /**
         * Scan regular expression matches in a given range in reverse order,
         * calling the given iterator function on each match.
         * @param regex? - A {RegExp} to search for.
         * @param range? - A {Range} in which to search.
         * @param iterator? - A {Function} that's called on each match with an {Object} containing the following keys:
         */
        backwardsScanInRange(regex? : RegExp, range? : Atom.Range, iterator? : Function) : Atom.Range;
    
        /**
         * Replace all regular expression matches in the entire buffer.
         * @param regex? - A {RegExp} representing the matches to be replaced.
         * @param replacementText? - A {String} representing the text to replace each match.
         * Returns a {Number} representing the number of replacements made.
         */
        replace(regex? : RegExp, replacementText? : string) : number;
    
        /**
         * Identifies if a character sequence is within a certain range.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param regex? - The {RegExp} to match.
         * @param startIndex? - A {Number} representing the starting character offset.
         * @param endIndex? - A {Number} representing the ending character offset.
         */
        matchesInCharacterRange(regex? : RegExp, startIndex? : number, endIndex? : number) : Atom.Range;
    
        /**
         * Get the range spanning from `[0, 0]` to {::getEndPosition}.
         */
        getRange() : Atom.Range;
    
        /**
         * Get the number of lines in the buffer.
         */
        getLineCount() : number;
    
        /**
         * Get the last 0-indexed row in the buffer.
         */
        getLastRow() : number;
    
        /**
         * Get the first position in the buffer, which is always `[0, 0]`.
         */
        getFirstPosition() : Point;
    
        /**
         * Get the maximal position in the buffer, where new text would be
         * appended.
         */
        getEndPosition() : Point;
    
        /**
         * Get the length of the buffer in characters.
         * Returns a {Number}.
         */
        getMaxCharacterIndex() : number;
    
        /**
         * Get the range for the given row
         * @param row? - A {Number} representing a 0-indexed row.
         * @param includeNewline? - A {Boolean} indicating whether or not to include the newline, which results in a range that extends to the start of the next line.
         */
        rangeForRow(row? : number, includeNewline? : boolean) : number;
    
        /**
         * Convert a position in the buffer in row/column coordinates to an
         * absolute character offset, inclusive of line ending characters.
         * 
         * The position is clipped prior to translating.
         * @param position? - A {Point}.
         */
        characterIndexForPosition(position? : Point) : Point;
    
        /**
         * Convert an absolute character offset, inclusive of newlines, to a
         * position in the buffer in row/column coordinates.
         * 
         * The offset is clipped prior to translating.
         * @param offset? - A {Number}.
         */
        positionForCharacterIndex(offset? : number) : Point;
    
        /**
         * Clip the given range so it starts and ends at valid positions.
         * 
         * For example, the position `[1, 100]` is out of bounds if the line at row 1 is
         * only 10 characters long, and it would be clipped to `(1, 10)`.
         * @param range? - A {Range} or range-compatible {Array} to clip.
         */
        clipRange(range? : Atom.Range) : Atom.Range;
    
        /**
         * Clip the given point so it is at a valid position in the buffer.
         * 
         * For example, the position (1, 100) is out of bounds if the line at row 1 is
         * only 10 characters long, and it would be clipped to (1, 10)
         * @param position? - A {Point} or point-compatible {Array}.
         */
        clipPosition(position? : Point) : Point;
    
        /**
         * Save the buffer. 
         */
        save() : void;
    
        /**
         * Save the buffer at a specific path.
         * @param filePath? - The path to save at. 
         */
        saveAs(filePath? : string) : void;
    
        /**
         * Reload the buffer's contents from disk.
         * 
         * Sets the buffer's content to the cached disk contents 
         */
        reload() : void;
    
        /**
         * Rereads the contents of the file, and stores them in the cache. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        updateCachedDiskContentsSync() : void;
    
        /**
         * Rereads the contents of the file, and stores them in the cache.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param flushCache? - {Boolean} flush option to pass through to
```
         {File::read} (default: false).
```
         * @param callback? - {Function} to call after the cached contents have
```
         been updated.
```
         */
        updateCachedDiskContents(flushCache? : boolean, callback? : any) : void;
    
        /**
         * Private Utility Methods
         * This field or method was marked private by atomdoc. Use with caution.
         */
        markerCreated(marker? : Marker) : Marker;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadSync() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        load() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        finishLoading() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroy() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isAlive() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isDestroyed() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isRetained() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        retain() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        release() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        subscribeToFile() : Pathwatcher.File;
    
        /**
         * Identifies if the buffer belongs to multiple editors.
         * 
         * For example, if the {EditorView} was split.
         * This field or method was marked private by atomdoc. Use with caution.
         * Returns a {Boolean}.
         */
        hasMultipleEditors() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        cancelStoppedChangingTimeout() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scheduleModifiedEvents() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        emitModifiedStatusChanged(modifiedStatus? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        logLines(start? : any, end? : any) : string[];
    
    }

    /**
     * Contains several patches that we want to undo/redo as a batch. 
     */
    class Transaction extends Serializable.Serializable {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        patches: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        oldMarkersSnapshot: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        newMarkersSnapshot: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(patches? : any, groupingInterval? : any, oldMarkersSnapshot? : any, newMarkersSnapshot? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        serializeParams() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deserializeParams(params? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        push(patch? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        invert(buffer? : boolean) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        applyTo(buffer? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        hasBufferPatches() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        merge(patch? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isOpenForGrouping() : boolean;
    
    }

}
declare module "text-buffer" {
    export = TextBuffer.TextBuffer;
}
