'use strict';
var P = require('parsimmon');
var regex = require('../regex');
var utils = require('../utils');
var id = P.regex(regex.label).desc('project name');
var semver = P.regex(regex.semverV).desc('semver');
var space = P.string(' ');
var colon = P.string(':');
var optColon = P.regex(/:?/);
var linebreak = P.regex(/\r?\n/).desc('linebreak');
var lineTrail = P.regex(/[ \t]*\r?\n/).desc('linebreak');
var tabSpace = P.regex(/[ \t]/).desc('tab or space');
var optTabSpace = P.regex(/[ \t]*/).desc('tab or space');
var optComma = P.regex(/,?/);
var url = P.regex(regex.uri).desc('url');
var urlBracket = P.string('<').then(url).skip(P.string('>'));
var bomOpt = P.regex(regex.bomOpt);
var comment = P.string('//');
var commentSpace = comment.skip(space);
var commentTab = comment.skip(tabSpace);
var comment3 = P.string('///').skip(space);
var nameUTF = P.regex(regex.nameUTF).desc('name');
var separatorComma = P.string(',').then(space.or(optTabSpace.then(linebreak).then(comment).then(tabSpace).then(optTabSpace)));
var separatorOptComma = P.seq(P.string(','), space).or(optTabSpace.then(optComma).then(linebreak).then(comment).then(tabSpace).then(optTabSpace));
var separatorProject = P.seq(P.string(','), space).or(optTabSpace.then(optComma).then(linebreak).then(comment).then(tabSpace).then(P.seq(P.string('Project:'), tabSpace).or(optTabSpace)));
exports.person = P.seq(nameUTF, space.then(urlBracket)).map(function (arr) {
    return {
        name: arr[0],
        url: arr[1] ? utils.untrail(arr[1]) : null
    };
}).skip(optTabSpace);
exports.label = P.string('// Type definitions for ').then(P.seq(id, space.then(P.string('(').then(P.seq(id, P.string(', ').then(id).many()).map(function (arr) {
    return [arr[0]].concat(arr[1]);
})).skip(P.string(')'))).or(P.succeed(null)))).map(function (arr) {
    regex.semverExtract.lastIndex = 0;
    var match = regex.semverExtract.exec(arr[0]);
    var semver = null;
    var label = arr[0];
    if (match) {
        label = match[1];
        semver = match[2];
    }
    return {
        name: label + (arr[1] ? ' (' + arr[1].join(', ') + ')' : ''),
        version: semver
    };
}).skip(optTabSpace);
exports.project = P.string('// Project: ').then(P.seq(url, separatorProject.then(url).many())).map(function (arr) {
    var ret = [];
    ret.push({
        url: utils.untrail(arr[0])
    });
    arr[1].forEach(function (url) {
        ret.push({
            url: utils.untrail(url)
        });
    });
    return ret;
}).skip(optTabSpace);
exports.authors = P.string('// Definitions by: ').then(P.seq(exports.person, separatorComma.then(exports.person).many())).map(function (arr) {
    var ret = arr[1];
    ret.unshift(arr[0]);
    return ret;
}).skip(optTabSpace);
exports.repo = P.string('// Definitions: ').then(url).map(function (url) {
    return {
        url: utils.untrail(url)
    };
}).skip(optTabSpace);
exports.header = bomOpt.then(P.seq(exports.label.skip(linebreak), exports.project.skip(linebreak), exports.authors.skip(linebreak), exports.repo.skip(linebreak))).skip(P.all).map(function (arr) {
    return {
        label: arr[0],
        project: arr[1],
        authors: arr[2],
        repository: arr[3]
    };
});
