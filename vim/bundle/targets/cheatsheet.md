## Pair mappings

Available mappings

     i(  i)  i{  i}  iB  i[  i]  ir  i<  i>  ia it
     a(  a)  a{  a}  aB  a[  a]  ar  a<  a>  aa at
     I(  I)  I{  I}  IB  I[  I]  Ir  I<  I>  Ia It
     A(  A)  A{  A}  AB  A[  A]  Ar  A<  A>  Aa At

    in( in) in{ in} inB in[ in] inr in< in> ina int
    an( an) an{ an} anB an[ an] anr an< an> ana ant
    In( In) In{ In} InB In[ In] Inr In< In> Ina Int
    An( An) An{ An} AnB An[ An] Anr An< An> Ana Ant

    il( il) il{ il} ilB il[ il] ilr il< il> ila ilt
    al( al) al{ al} alB al[ al] alr al< al> ala alt
    Il( Il) Il{ Il} IlB Il[ Il] Ilr Il< Il> Ila Ilt
    Al( Al) Al{ Al} AlB Al[ Al] Alr Al< Al> Ala Alt

Chart for a list of pairs

```
                           ..........
a ( bbbbbbbb ) ( ccccccc ) ( dddddd ) ( eeeeeee ) ( ffffffff ) g
  ││└ 2Il) ┘│││││└ Il) ┘│││││└ I) ┘│││││└ In) ┘│││││└ 2In) ┘│││
  │└─ 2il) ─┘│││└─ il) ─┘│││└─ i) ─┘│││└─ in) ─┘│││└─ 2in) ─┘││
  ├── 2al) ──┘│├── al) ──┘│├── a) ──┘│├── an) ──┘│├── 2an) ──┘│
  └── 2Al) ───┘└── Al) ───┘└── A) ───┘└── An) ───┘└── 2An) ───┘
```

Chart for nested pairs

```
                           ..........
a ( b ( cccccccc ) d ) ( e ( ffffff ) g ) ( h ( iiiiiiii ) j ) k
  │││ ││└ 2Il) ┘││││││││││ ││└ I) ┘││││││││││ ││└ 2In) ┘│││││││
  │││ │└─ 2il) ─┘│││││││││ │└─ i) ─┘│││││││││ │└─ 2in) ─┘││││││
  │││ ├── 2al) ──┘││││││││ ├── a) ──┘││││││││ ├── 2an) ──┘│││││
  │││ └── 2Al) ───┘│││││││ └── A) ───┘│││││││ └── 2An) ───┘││││
  ││└───── Il) ────┘│││││└─── 2I) ────┘│││││└───── In) ────┘│││
  │└────── il) ─────┘│││└──── 2i) ─────┘│││└────── in) ─────┘││
  ├─────── al) ──────┘│├───── 2a) ──────┘│├─────── an) ──────┘│
  └─────── Al) ───────┘└───── 2A) ───────┘└─────── An) ───────┘
```

## Quote mappings

Available mappings

```
 i'  i"  i`    in' in" in`    il' il" il`
 a'  a"  a`    an' an" an`    al' al" al`
 I'  I"  I`    In' In" In`    Il' Il" Il`
 A'  A"  A`    An' An" An`    Al' Al" Al`
```

Chart for a list of quotes

```
             .............
a ' bbbbbbb ' c ' dddddd ' e ' fffffff ' g
  ││└ Il' ┘│││  ││└ I' ┘│││  ││└ In' ┘│││
  │└─ il' ─┘││  │└─ i' ─┘││  │└─ in' ─┘││
  ├── al' ──┘│  ├── a' ──┘│  ├── an' ──┘│
  └── Al' ───┘  └── A' ───┘  └── An' ───┘
```

## Separator mappings

Available mappings

```
 i,  i.  i;  i:  i+  i-  i=  i~  i_  i*  i#  i/  i|  i\  i&  i$
 a,  a.  a;  a:  a+  a-  a=  a~  a_  a*  a#  a/  a|  a\  a&  a$
 I,  I.  I;  I:  I+  I-  I=  I~  I_  I*  I#  I/  I|  I\  I&  I$
 A,  A.  A;  A:  A+  A-  A=  A~  A_  A*  A#  A/  A|  A\  A&  A$

in, in. in; in: in+ in- in= in~ in_ in* in# in/ in| in\ in& in$
an, an. an; an: an+ an- an= an~ an_ an* an# an/ an| an\ an& an$
In, In. In; In: In+ In- In= In~ In_ In* In# In/ In| In\ In& In$
An, An. An; An: An+ An- An= An~ An_ An* An# An/ An| An\ An& An$

il, il. il; il: il+ il- il= il~ il_ il* il# il/ il| il\ il& il$
al, al. al; al: al+ al- al= al~ al_ al* al# al/ al| al\ al& al$
Il, Il. Il; Il: Il+ Il- Il= Il~ Il_ Il* Il# Il/ Il| Il\ Il& Il$
Al, Al. Al; Al: Al+ Al- Al= Al~ Al_ Al* Al# Al/ Al| Al\ Al& Al$
```

Chart for a list of separators

```
                       .........
a , bbbbbbbb , ccccccc , dddddd , eeeeeee , ffffffff , g
  ││└ 2Il, ┘│││└ Il, ┘│││└ I, ┘│││└ In, ┘│││└ 2In, ┘│ │
  │└─ 2il, ─┤│├─ il, ─┤│├─ i, ─┤│├─ in, ─┤│├─ 2in, ─┤ │
  ├── 2al, ─┘├┼─ al, ─┘├┼─ a, ─┘├┼─ an, ─┘├┼─ 2an, ─┘ │
  └── 2Al, ──┼┘        └┼─ A, ──┼┘        └┼─ 2An, ───┘
             └─  Al,  ──┘       └─  An,  ──┘
```

## Argument mappings

Available mappings

```
     ia  aa  Ia  Aa
    ina ana Ina Ana
    ila ala Ila Ala
```

Chart for arguments

```
                         .........
a ( bbbbbb , ccccccc , d ( eeeeee , fffffff ) , gggggg ) h
  ││├2Ila┘│││└─Ila─┘││││ ││├─Ia─┘│││└─Ina─┘│││││└2Ina┘│ │
  │└┼2ila─┘│├──ila──┤│││ │└┼─ia──┘│├──ina──┤│││├─2ina─┤ │
  │ └2ala──┼┤       ││││ │ └─aa───┼┤       │││├┼─2ana─┘ │
  └──2Ala──┼┘       ││││ └───Aa───┼┘       │││└┼─2Ana───┘
           ├───ala──┘│││          ├───ana──┘││ │
           └───Ala───┼┤│          └───Ana───┼┤ │
                     ││└─────2Ia────────────┘│ │
                     │└──────2ia─────────────┤ │
                     ├───────2aa─────────────┘ │
                     └───────2Aa───────────────┘
```

## Customize seeking

Seeking is controlled by the setting `g:targets_seekRanges`. Default value:

```vim
let g:targets_seekRanges = 'cc cr cb cB lc ac Ac lr rr ll lb ar ab lB Ar aB Ab AB rb al rB Al bb aa bB Aa BB AA'
```

When using a command like `cib` to change inside a block, targets.vim considers
the three targets:

  - smallest target around cursor
  - next target after cursor
  - last target before cursor

For each of those that were found, we detect what range type it has. A range
type depends on the relative position of the start and end of the target,
relative to the current cursor position and the currently visible lines.

The possibly relative positions are:

  - `c`: on cursor position
  - `l`: left of cursor in current line
  - `r`: right of cursor in current line
  - `a`: above cursor on screen
  - `b`: below cursor on screen
  - `A`: above cursor off screen
  - `B`: below cursor off screen

All possibly ranges are listed below, denoted by two characters: one for the
relative start and one for the relative end position of the target. For
example, `lr` means "from left of cursor to right of cursor in cursor line".

Next to each range type is a pictogram of an example. They are made of these
symbols:

  - `.`: current cursor position
  - `(`: start of target
  - `)`: end of target
  - `/`: line break before and after cursor line
  - `|`: screen edge between hidden and visible lines

#### Ranges on cursor:

```
cc   |  /  O  /  |   target equals cursor position (single character)
cr   |  /  () /  |   starting on cursor, current line
cb   |  /  (  /) |   starting on cursor, multiline down, on screen
cB   |  /  (  /  |)  starting on cursor, multiline down, partially off screen
lc   |  / ()  /  |   ending on cursor, current line
ac   | (/  )  /  |   ending on cursor, multiline up, on screen
Ac  (|  /  )  /  |   ending on cursor, multiline up, partially off screen
```

#### Ranges around cursor:

```
lr   |  / (.) /  |   around cursor, current line
lb   |  / (.  /) |   around cursor, multiline down, on screen
ar   | (/  .) /  |   around cursor, multiline up, on screen
ab   | (/  .  /) |   around cursor, multiline both, on screen
lB   |  / (.  /  |)  around cursor, multiline down, partially off screen
Ar  (|  /  .) /  |   around cursor, multiline up, partially off screen
aB   | (/  .  /  |)  around cursor, multiline both, partially off screen bottom
Ab  (|  /  .  /) |   around cursor, multiline both, partially off screen top
AB  (|  /  .  /  |)  around cursor, multiline both, partially off screen both
```

#### Ranges after (right of/below) cursor

```
rr   |  /  .()/  |   after cursor, current line
rb   |  /  .( /) |   after cursor, multiline, on screen
rB   |  /  .( /  |)  after cursor, multiline, partially off screen
bb   |  /  .  /()|   after cursor below, on screen
bB   |  /  .  /( |)  after cursor below, partially off screen
BB   |  /  .  /  |() after cursor below, off screen
```

#### Ranges before (left of/above) cursor

```
ll   |  /().  /  |   before cursor, current line
al   | (/ ).  /  |   before cursor, multiline, on screen
Al  (|  / ).  /  |   before cursor, multiline, partially off screen
aa   |()/  .  /  |   before cursor above, on screen
Aa  (| )/  .  /  |   before cursor above, partially off screen
AA ()|  /  .  /  |   before cursor above, off screen
```

Pictogram legend:

```
    A  a  l r  b  B  relative positions
     └───────────┘   visible screen
        └─────┘      current line
```

Given the range types of our targets, we then pick the one that appears first
in `g:targets_seekRanges`. If none is found, the selection fails.

The default setting generally prefers targets around the cursor, with one
exception: If the target around the cursor is not contained in the current
cursor line, but the next or last target are, then prefer those. Targets
beginning or ending on the cursor are preferred over everything else.

Some other useful example settings:

Prefer multiline targets around cursor over distant targets within cursor line:
```vim
let g:targets_seekRanges = 'cc cr cb cB lc ac Ac lr lb ar ab lB Ar aB Ab AB rr ll rb al rB Al bb aa bB Aa BB AA'
```

Never seek backwards:
```vim
let g:targets_seekRanges = 'cc cr cb cB lc ac Ac lr rr lb ar ab lB Ar aB Ab AB rb rB bb bB BB'
```

Only seek if next/last targets touch current line:
```vim
let g:targets_seekRanges = 'cc cr cb cB lc ac Ac lr rr ll lb ar ab lB Ar aB Ab AB rb rB al Al'
```

Only consider targets fully visible on screen:
```vim
let g:targets_seekRanges = 'cc cr cb cB lc ac Ac lr lb ar ab rr rb bb ll al aa'
```

Only consider targets around cursor:
```vim
let g:targets_seekRanges = 'cc cr cb cB lc ac Ac lr lb ar ab lB Ar aB Ab AB'
```

Only consider targets fully contained in current line:
```vim
let g:targets_seekRanges = 'cc cr cb cB lc ac Ac lr rr ll'
```
