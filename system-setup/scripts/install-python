#!/bin/sh

set -e

export PYENV_ROOT="${1:-${PYENV_ROOT:-${XDG_DATA_HOME:-$HOME/.local/share}/pyenv}}"
PATH="$(dirname "$0"):$PYENV_ROOT/bin:$HOME/.local/bin:$PATH"

export PYTHONNOUSERSITE=1
export CFLAGS="${CFLAGS--O2}"
if [ -z "$CONFIGURE_OPTS" ] && [ -z "$PYTHON_CONFIGURE_OPTS" ]; then
    export PYTHON_CONFIGURE_OPTS="\
        --enable-shared \
        --with-threads \
        \
        --with-system-expat \
        --with-system-zlib \
        --with-system-ffi \
        --with-system-libmpdec \
        --with-dbmliborder=gdbm:ndbm \
        \
        --enable-optimizations \
        --with-lto \
        \
        --enable-ipv6 \
        --enable-unicode=ucs4 \
        --enable-loadable-sqlite-extensions \
        --with-computed-gotos \
    "
fi

pyenv-installer
eval "$(pyenv init -)"
pyenv install 2.7.15
pyenv global 2.7.15
pyenv install 3.6.6
pyenv global 2.7.15 3.6.6

# At this point python is python2, and python2 and python3 work as expected,
# but python tools run with these pythons will have that python install first
# in the PATH. In the case of python3, this means in that process, 'python'
# will now correspond to python3, which will not do (see bitbake).
rm -f "$(dirname "$(pyenv which python3)")"/python
