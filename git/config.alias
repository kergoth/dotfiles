# vim: set noet sts=0 sw=0 ft=gitconfig :

[alias]
	git = !exec git
	ci = commit -s
	ic = commit -s
	cm = commit -s -m
	cma = commit -sam
	co = checkout
	cp = cherry-pick -x
	au = add -u
	st = status -sb
	sti = status -sb --ignored
	br = branch
	id = rev-parse
	ls = ls-files --exclude-standard
	lsi = ls-files --exclude-standard --directory -oi
	ll = "!f() { cd \"$GIT_PREFIX\" && git ls-files -z --exclude-standard \"$@\" | xargs -0 -n1 -I{} -- git log -1 --format=\"%ai {}\" -- \"{}\" | sort; }; f"
	lsl = ll
	d = diff
	dc = diff --cached
	staged = diff --cached
	ignored = lsi
	r = remote -v
	fetchall = fetch --all
	b = branch -v
	ri = rebase -i
	addnp = "!f(){ git add -N "$@" && git add -p "$@"; }; f"

	# Hub
	fork = !hub fork
	pull-request = !hub pull-request
	browse = !hub browse
	create = !hub create

	# Update without merge commits
	up = !git fetch "$(git tracking-remote)" && git merge --no-ff "@{u}"

	# Update with rebase, re-applying merges
	upr = !git fetch "$(git tracking-remote)" && git rebase -p "@{u}"
	purr = !git upr

	# Push with lease
	please = push --force-with-lease

	# remove changes to a file from the index
	unstage = reset HEAD --

	# revert a file or files to the version in the index
	revert-file = checkout --
	rf = checkout --

	# Amend the current commit, but don't prompt to edit the commit message
	amend = commit --amend -C HEAD

	# Clean out the ignored files (i.e. to rebuild)
	iclean = xclean -Xf

	# Pretty one line logs
	lg = log --graph --pretty=format:'%Cred%h%Creset %Cgreen%ad%Creset -%C(yellow)%d%Creset %s %C(bold blue)<%an>%Creset' --date=short
	lga = !git lg --all
	l = !git lg -n25
	ejlg = "!f(){ GIT_PAGER=\"emojify | $(git config core.pager || echo less -RFX)\" git lg \"$@\"; }; f"

	# Log of all dangling commits
	dangling = !git fsck | sed -n 's/^dangling commit //p' | git log --stdin --no-walk -g --first-parent -m -p
	lgd = dangling

	# Remove existing files from the index
	forget = update-index --force-remove

	# Stash
	ss = stash save
	sl = stash list --pretty=format:'%C(yellow)%gd%Creset: %Cgreen%cr%Creset - %s'
	sln = "!f(){ git -c color.ui=always stash list --pretty=format:'%C(yellow)%gd%Creset: %Cgreen%cr%Creset - %s' \"$@\" | grep -Ev 'WIP|Reset from'; }; f"
	sa = stash apply
	sd = stash drop
	sp = stash pop
	sb = stash branch

	# Drop the current modifications. Stashes, then drops the stash,
	# leaving a dangling commit with the changes.
	drop = "!f(){ git mstash \"$@\" dropped && git stash drop; }; f"
	dropped = dangling '--grep=: dropped'

	# Save the current modifications to the stash, but keep them.
	save = "!f(){ git mstash \"$@\" saved && git stash apply; }; f"
	save-all = save --include-untracked

	# Save to the stash, including the specified files, then remove them
	save-rm = '!f(){ git save --include-untracked && rm \"$@\"; }; f'

	# Pretty one line log showing commits in the last hour/day/week/month/etc
	last = "!f(){ if [ $# -gt 0 ]; then since="$1"; shift; else since="week"; fi; git lg --since=\"last $since\" "$@"; }; f"

	# example: git subdo pull
	subdo = submodule foreach git

	# Merge the contents of the previous HEAD ref (via reflog)
	merge-old-head = merge --ff HEAD@{1}

	# Show repo root
	root = rev-parse --show-toplevel

	# Repo local task lists
	bug = !t.py -t $(git root) -l BUGS
	todo = !t.py -t $(git root) -l TODO

	# show list of contributors in descending order by number of commits
	authors = shortlog -sne --no-merges

	# given a string for an author, try to figure out full name and email:
	whois = "!sh -c 'git log -i -1 --pretty=\"format:%an <%ae>%n\" --author=\"$1\"' -"

	# given any git object, try to show it briefly
	whatis = show -s --pretty='tformat:%h (%s, %ad)' --date=short

	# what changed between ORIG_HEAD and current
	lc = log ORIG_HEAD.. --stat --no-merges

	# list the largest files in the repository
	ls-large-files = !git ls-tree -rl HEAD | sort -rnk 4 | head

	# Diffstat of uncached changes, ignoring whitespace
	ds = !git --no-pager diff --stat -M -w

	# Create a new, entirely empty branch with no commits
	empty-branch = "!sh -e -c 'git symbolic-ref HEAD \"refs/heads/$1\"; rm -f $(git rev-parse --git-dir)/index; git clean -fdx' \"$@\""

	# Edit the unmerged files
	edit-unmerged = "!f() { git ls-files --unmerged | cut -f2 | sort -u ; }; $EDITOR `f`"

	# Compare two commits with interdiff (used to compare two commits which implement the same feature, for example)
	intercommit = !sh -c 'git show "$1" > .git/commit1 && git show "$2" > .git/commit2 && interdiff .git/commit[12] | less -FRS' -

	tracking-remote = "!f() { git rev-parse --symbolic-full-name '@{u}' | sed -n 's,refs/remotes/\\([^/][^/]*\\)/.*,\\1,p'; }; f"
	tracking-ref = rev-parse --symbolic-full-name @{u}
	remote-ref = rev-parse --symbolic-full-name @{u}
	in = !git fetch && git lg \"..@{u}\"
	out = !git fetch && git lg \"@{u}..\"

	# Rebase the current branch on its upstream
	rebase-upstream = rebase -i @{u}
	ru = rebase-upstream

	# Run a topic branch interdiff between HEAD and upstream
	tbdiff-upstream = tbdiff @{u}...HEAD
	tbdiff-old-head = tbdiff HEAD@{1}...HEAD

	# Run git test-sequence against the commits we'll be pushing
	test-outgoing = !git test-sequence @{u}..

	# Non-interactive git rebase -x
	rebase-test = !git -c core.editor=/bin/true rebase -ix
	rebase-test-i = rebase -ix

	# For each submodule
	subs = submodule foreach --recursive

	# Update submodules
	update-subs = submodule foreach --recursive "git fetch && git checkout `git remote-ref`"

