#!/usr/bin/env python3
#
# TODO: implement the article caching as advised by pocket
# TODO: implement tag exclusion
# TODO: add option to just dump the article json to stdout and let the
# user sort it out with jq or whatnot
# TODO: only show reading time for articles
# TODO: grab and dump other useful info

import click
import errno
import itertools
import math
import os
import subprocess
import sys
from appdirs import AppDirs
from configparser import ConfigParser
from pocket import Pocket
from pprint import pprint

DEFAULT_WORDS_PER_MINUTE = 180
NAME = os.path.basename(__file__)


def load_pocket_config():
    config = ConfigParser()
    with open(os.path.expanduser('~/.pocket-config')) as f:
        config.read_file(f)
    return config['pocket']


def init_pocket(config):
    key = config.get('consumer_key')
    token = config.get('access_token')
    pocket = Pocket(key, token)
    return pocket


def makedirs(path):
    try:
        os.makedirs(path)
    except OSError as exc:
        if exc.errno != errno.EEXIST:
            raise


@click.command()
@click.argument('search', default='')
@click.option('--state', '-s',
              type=click.Choice(['unread', 'archive', 'all']),
              default='unread')
@click.option('--tags', '-t', default='',
              help='Comma-separated list of tags. Prepending "-" to the tag will exclude.')
@click.option('--ignored-tags', '-i', default='',
              help='Comma-separated list of tags which are ignored. I.e. are not considered for __untagged__.')
@click.option('--sort', '-o',
              type=click.Choice(['newest', 'oldest', 'title', 'site']),
              default='newest')
def search(search, state, tags, ignored_tags, sort):
    dirs = AppDirs(NAME)
    makedirs(dirs.user_cache_dir)

    tags = [t for t in (t.strip() for t in tags.split(',')) if t]
    ignored_tags = [t for t in (t.strip() for t in ignored_tags.split(',')) if t]
    articles = _search(search, state, tags, ignored_tags, sort)
    for article in articles:
        if article['reading_time'] == -1:
            article['reading_time'] = ''

        elements = []
        for key in ['id', 'url', 'title', 'tags', 'reading_time']:
            value = article[key]
            if key == 'reading_time' and value:
                value = '%s Mins' % value
            elements.append(str(value))
        print('\t'.join(elements))


def _search(search, state, tags, ignored_tags, sort):
    try:
        pocket_config = load_pocket_config()
    except OSError:
        subprocess.check_call(['pocket-cli', 'fetch'])
        pocket_config = load_pocket_config()

    wpm = pocket_config.get('words_per_minute', DEFAULT_WORDS_PER_MINUTE)
    wpm = int(wpm)

    pocket = init_pocket(pocket_config)
    articles = pocket.retrieve(search=search,
                               state=state,
                               sort=sort,
                               detailType='complete')
    if not articles['list']:
        return

    ignored_tags = set(ignored_tags)
    grouped_tags = dict((k, set(v or [])) for k, v in itertools.groupby(sorted(tags), lambda t: t.startswith('-')))
    with_tags, without_tags = grouped_tags.get(False), grouped_tags.get(True)
    if without_tags:
        without_tags = set(t[1:] for t in without_tags)

    for article_id, article in articles['list'].items():
        word_count = int(article.get('word_count', 0))
        if word_count == 0:
            reading_time = -1
        else:
            reading_time = int(math.ceil(word_count / wpm))

        title = article.get('resolved_title') or article['given_title']
        url = article.get('resolved_url') or article['given_url']

        if 'tags' in article:
            article_tags = set(article['tags'].keys())
            article_tags -= ignored_tags 
        else:
            article_tags = set()

        if without_tags and (set(without_tags) & article_tags):
            continue

        if with_tags:
            if '__untagged__' in with_tags:
                if len(with_tags) > 1:
                    sys.exit('Error: cannot combine __untagged__ with other included tags')
                if article_tags:
                    continue
            elif not article_tags.issuperset(with_tags):
                continue

        tagstr = ','.join(sorted(article_tags))
        yield {
                'id': article_id,
                'reading_time': reading_time,
                'title': title,
                'url': url,
                'tags': tagstr,
              }


if __name__ == '__main__':
    search()
