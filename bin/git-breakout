#!/bin/bash
#
# git-breakout - break out every patches from a GIT repository
#
# Author:	Nicolas Pitre
# Created:	Mar 08, 2006
#
# This script finds out all the v2.6.* tags in a git repository, including
# the v2.6.*-rc* tags, and generates patches for the corresponding commits
# between two consecutive tags.
#
# Those patches are stored in subdirectories which name is the nearest tag
# containing given commits. Those subdirectories are created within the
# $destdir directory.
#
# The script can be re-run whenever a new release has been tagged in order
# to pick up the new patches and only those patches.  Tagged revisions which
# subdirectories already exist are skipped.  Incidentally, if one doesn't
# want to generate patches for v2.6.13 then simply doing:
#
#	touch ${destdir}v2.6.13
#
# is enough for that version to be skipped.  And to regenerate patches
# for v2.6.13 then simply doing:
#
#	rm -rf ${destdir}v2.6.13
#
# and re-running this script will do it.

destdir="break-out/"

diff_opts=""

revs=$(
	cd .git/refs/tags/
	for n in $(seq 10 100)
	do
		ls v2.6.$n-rc? 2>/dev/null
		ls v2.6.$n-rc?? 2>/dev/null
		ls v2.6.$n 2>/dev/null
	done
)

title_to_name='
	/./d
	/^$/n
	s/^\[PATCH[^]]*\] *//
	s/[^-a-z.A-Z_0-9]/-/g
	s/\.\.\.*/\./g
	s/\.*$//
	s/--*/-/g
	s/^-//
	s/-$//
	s/$/./
	p
	q
'

dump_patches () {
	i=1
	git-cherry "$1" "$2" |
	while read sign commit
	do
		[ "$sign" == "+" ] || continue
		name=$(git-cat-file commit $commit | sed -ne "$title_to_name")
		file=$(printf '%04d-%spatch' $i "$name")
		echo "  $file"
		git-diff-tree -p --pretty $diff_opts "$commit" |
		(echo "Commit: $commit"; tail +2) > $destdir$2/$file
		i=$(expr "$i" + 1)
	done
}

echo "Destination directory: $destdir"
to=
for rev in $revs
do
	from=$to
	to=$rev
	[ "$from" == "" ] && continue
	if [ -e "$destdir$to" ]
	then
		echo "Skipping $to (directory already exists)"
		continue
	fi
	mkdir -p $destdir$to || exit
	echo "Processing $from..$to"
	dump_patches "$from" "$to"
done
