#!/bin/sh
#
# git-cached-clone
#
# Clone a url to a destination, as git clone does, but cache as well, such
# that all clones of a given url share the same core git objects, which saves
# disk space and reduces the load on the git server.  This is transparent to
# the user of the cloned repository, as it still points at upstream, and
# future updates from that clone will use the original URL, not the cache.
#
# If you attempt to clone a URL while offline, and the url has been cached, it
# will still give you an entirely functional cloned repository, but its
# contents will be based upon the most recent cache update.
#
# This updates the cache for a given URL whenever you clone from that URL.

set -e

cachedir=$HOME/.git-cache
recursive=0

main () {
    process_options "$@" || usage
    if [ $OPTIND -eq 1 -a $# -eq 0 ]; then
        usage
    fi
    shift $(($OPTIND - 1))

    if [ $# -lt 1 -o $# -gt 2 ]; then
        usage
    fi

    url="$1"
    shift
    if ! echo "$url" | grep -q "\.git/\?$"; then
        url="$url.git"
    fi

    dest="$1"
    if [ -z "$dest" ]; then
        dest="$(basename_url "$url")"
    fi

    cache_url="$(get_cache_url "$url")"
    cached="$(get_cache_dir "$cache_url")"

    add_to_cache "$cache_url" "$cached"
    cache_clone "$url" "$cache_url" "$cached" "$dest"
}

process_options () {
    while getopts lsurRha: opt; do
        case "$opt" in
            R)
                recursive=1
                ;;
            l|s|u|r|a)
                if [ $# -ge $OPTIND ]; then
                    usage
                fi
                case "$opt" in
                    l)
                        list_cache
                        ;;
                    s)
                        sanitize_cache
                        ;;
                    u)
                        update_cache
                        ;;
                    r)
                        repack_cache
                        ;;
                    a)
                        url="$OPTARG"
                        cache_url="$(get_cache_url "$url")"
                        cached="$(get_cache_dir "$cache_url")"

                        if [ ! -e "$cached" ]; then
                            add_to_cache "$cache_url" "$cached"
                            echo "$url added to cache at $cached."
                        else
                            echo "$url already in cache at $cached, skipping."
                        fi
                        ;;
                esac
                exit 0
                ;;
            \?|h)
                return 1
                ;;
       esac
    done
}

list_cache () {
    echo "Cached repositories:"
    for repo in $cachedir/*/; do
        git "--git-dir=$repo" config --get-regexp "remote\..*\.url" | \
            while read entry url; do
                echo "  $url"
            done
    done
}

sanitize_cache () {
    for repo in $cachedir/*/; do
        git "--git-dir=$repo" config --get-regexp "remote\..*\.url" | \
            while read entry url; do
                adjusted_url="$(get_cache_url "$url")"
                if [ "$url" != "$adjusted_url" ]; then
                    git "--git-dir=$repo" remote set-url origin "$adjusted_url"
                    echo "Changed url for $repo to $adjusted_url"
                fi
            done
    done
}

update_cache () {
    for repo in $cachedir/*/; do
        git "--git-dir=$repo" fetch --all
    done
}

repack_cache () {
    for repo in $cachedir/*/; do
        git "--git-dir=$repo" repack -A -d
        git "--git-dir=$repo" gc
    done
}

usage () {
    cat >&2 <<END
Usage: git cached-clone [OPTIONS] URL [DEST]

       Options:

           -R      Recursive -- also clone submodules

       git cached-clone -a URL
         Add repository to the cache

       git cached-clone -l
         List cloned repositories

       git cached-clone -s
         Sanitize cloned repositories

       git cached-clone -u
         Update cloned repositories

       git cached-clone -r
         Repack cloned repositories
END
    exit 0
}

get_cache_url () {
    url="$(proper_url "$1")"
    git config --global --get-regexp "url\..*\.insteadof" | {
        while read real other; do
            realurl="$(echo "$real"|sed 's,^url\.,,; s,\.insteadof$,,')"
            if echo "$url" | grep -q "^$other"; then
                echo $url | sed -e "s,^$other,$realurl,"
                return
            fi
        done
        echo "$url"
    }
}

proper_url () {
    url="$1"
    echo "$url" | \
        sed -e 's,^git://github,https://github,' \
            -e 's,^http://github,https://github,' \
            -e 's,^git://openembedded.org,git://git.openembedded.org,'
}

basename_url () {
    url="$1"
    desturl="$(echo "$url"|tr ':' '/'|sed 's,\.git/*$,,')"
    sanitize "$(basename "$desturl")"
}

add_to_cache () {
    url="$1"; cached="$2"
    remote="$(hash "$url")"
    if [ -d "$cached" ]; then
        return 0
    fi

    mkdir -p "$cached"
    git "--git-dir=$cached" init --quiet --bare
    update_cache_entry "$url" "$cached" || true
}

update_cache_entry () {
    url="$1"; cached="$2"
    remote="$(hash "$url")"

    git "--git-dir=$cached" config remote.$remote.url "$(proper_url "$url")"
    git "--git-dir=$cached" config remote.$remote.fetch "+refs/*:refs/remotes/$remote/*"
    git "--git-dir=$cached" config remote.$remote.tagopt "--no-tags"
    git "--git-dir=$cached" fetch $remote
}

cache_clone () {
    url="$1"; cache_url="$2"; cached="$3"; dest="$4"
    cache_remote="$(hash "$cache_url")"
    if [ -d "$dest" ]; then
        echo >&2 "Error: $dest already exists"
        exit 1
    fi
    mkdir -p "$dest"
    cd $dest
    git init --quiet
    mkdir -p .git/objects/info
    echo "$cached/objects" > .git/objects/info/alternates
    git config remote.origin.url "$cached"
    git config remote.origin.fetch "+refs/remotes/$cache_remote/tags/*:refs/tags/*"
    git config --add remote.origin.fetch "+refs/remotes/$cache_remote/heads/*:refs/remotes/origin/*"
    git fetch origin

    git config remote.origin.url "$url"
    git config --replace-all remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
    git co -q -b master origin/master

    if [ $recursive -eq 1 ]; then
        clone_submodules
    fi
    cd - >/dev/null
}

clone_submodules () {
    if [ ! -e .gitmodules ]; then
        return
    fi

    git submodule init
    GIT_CONFIG=.gitmodules git config --get-regexp submodule\\..\*\\.path | while read key path; do
        name=$(echo $key|sed -e's,^submodule\.,,; s,\.path$,,')
        url=$(GIT_CONFIG=.gitmodules git config --get submodule.$name.url)
        rm -rf $name
        main -R $url $name
    done
    git submodule update
}

get_cache_dir () {
    url="$1"
    echo "$cachedir/$(basename_url "$url").git"
}

has () {
    which "$1" >/dev/null
}

hash () {
    echo "$@" | {
        if has sha1sum; then
            sha1sum | cut -c1-7
        elif has shasum; then
            shasum | cut -c1-7
        else
            md5sum | cut -c1-7
        fi
    }
}

sanitize () {
    echo "$@" | tr "[:upper:]" "[:lower:]" | \
                tr "[]()&~@#%^&*()_+=;:,\$/" " " | tr " " "_"
}

main "$@"
