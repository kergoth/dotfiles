#!/usr/bin/env bash

set -u

osname="$(uname -s)"

: ${XDG_CONFIG_HOME:=~/.config}
: ${XDG_DATA_HOME:=~/.local/share}

case "$OSTYPE" in
    darwin*)
        : ${XDG_CACHE_HOME:=~/Library/Caches}
        ;;
    *)
        : ${XDG_CACHE_HOME:=~/.cache}
        if [ "$OSTYPE" = linux-gnu ]; then
            case "$(uname -r)" in
                *-Microsoft)
                    OSTYPE=WSL
                    osname=Wsl
                    USERPROFILE="${USERPROFILE:-$(wslpath "$(cmd.exe /D /C 'SET /P <NUL=%USERPROFILE%' 2>/dev/null)")}"
                    ;;
            esac
        fi
        ;;
esac

mkdir -p $XDG_CONFIG_HOME $XDG_DATA_HOME $XDG_CACHE_HOME

HOSTNAME=$(hostname -s)
prefixes="%include %include%${osname} %include%${HOSTNAME}"
if [ "$osname" = Wsl ]; then
    prefixes="%include%Linux $prefixes"
fi
force=0
exclude=""
include=

set_launchd () {
    var="$1"
    value="$2"

    case "$OSTYPE" in
        darwin*)
            ;;
        *)
            return
            ;;
    esac

    plist_set () {
        plist_key="$(printf "%s" "$1" | sed "s/'/\\\\'/g")"
        plist_val="$(printf "%s" "$2" | sed "s/'/\\\\'/g")"
        if /usr/libexec/PlistBuddy -c "Print '$plist_key'" "$3" >/dev/null 2>&1; then
            /usr/libexec/PlistBuddy -c "Set '$plist_key' '$plist_val'" "$3"
        else
            /usr/libexec/PlistBuddy -c "Add '$plist_key' "${4:-string}" '$plist_val'" "$3"
        fi
    }

    mkdir -p ~/.MacOSX
    plist_set "$var" "$value" ~/.MacOSX/environment.plist

    if which launchctl &>/dev/null; then
        launchctl setenv "$var" "$value"
    fi

    if [ ! -e ~/Library/PreferencePanes/EnvPane.prefPane ]; then
        printf >&2 "Warning: EnvPane is not installed, set of env var %s to %s will not persist\n" "$var" "$value"
    fi
}

should_replace () {
    if ! [ -e "$1" ] && ! [ -L "$1" ]; then
        return 0
    fi

    if [ $force -eq 0 ]; then
        while true; do
            read -n 1 -p "Replace existing $1? [Y|n] " will_continue
            printf "\n"
            case "$will_continue" in
                [yY]|"")
                    return 0
                    ;;
                [nN])
                    return 1
                    ;;
                *)
                    echo >&2 "Invalid input '$will_continue'"
                    ;;
            esac
        done
    else
        return 1
    fi
}

relpath () {
    python -c "import os,sys; print(os.path.relpath(*sys.argv[1:]) if os.path.commonprefix(sys.argv[1:]) != '/' else sys.argv[1])" "$@"
}

copy () {
    link -c "$@"
}

link () {
    # Link a file to a destination using a relative path, with particular
    # convenience handling for dotfiles. ex.:
    #
    # link zsh/.zshenv.redir ~/.zshenv.redir
    # link zshrc       # links to ~/.zshrc (relatively)
    # link config/curl # links to ~/.config/curl (relatively)
    if [ "$1" = "-c" ]; then
        copy=1
        shift
    else
        copy=0
    fi
    dotfile="$(abspath "$1")"
    if [ $# -gt 1 ]; then
        dotfile_dest="$(abspath "$2")"
    else
        dotfile_base="${dotfile##*/}"
        case "$dotfile_base" in
            .*)
                dotfile_dest="$HOME/$dotfile_base"
                ;;
            *)
                dotfile_dest="$HOME/.$dotfile_base"
                ;;
        esac
    fi
    destdir="${dotfile_dest%/*}"
    if [ "$destdir" != "$dotfile_dest" ]; then
        mkdir -p "$destdir"
    fi

    if command -v python >/dev/null 2>&1; then
        dotfile_relpath="$(relpath "$dotfile" "$destdir" 2>/dev/null)"

        case "$dotfile_relpath" in
            /*)
                ;;
            *)
                # Sanity check
                dotfile_resolved="$(normalize_path "${dotfile_dest%/*}/$dotfile_relpath")"
                if [ ! -e "$dotfile_resolved" ]; then
                    echo >&2 "Error: $dotfile_resolved does not exist"
                    return 1
                fi
                ;;
        esac
    else
        dotfile_relpath="$dotfile"
    fi

    wsl_winpath=0
    if [ $OSTYPE = WSL ]; then
        win_dotfile_dest="$(wslpath -w "$dotfile_dest")"
        case "$win_dotfile_dest" in
            \\\\*)
                ;;
            *)
                wsl_winpath=1
                ;;
        esac
    fi

    if [ -L "$dotfile_dest" ]; then
        rm -f "$dotfile_dest"
    elif [ $wsl_winpath -eq 1 ]; then
        existing_dest="$(powershell.exe -c "(Get-Item $win_dotfile_dest).Target" 2>/dev/null)"
        if [ -n "$existing_dest" ]; then
            rm -f "$dotfile_dest"
        fi
    fi

    if [ -e "$dotfile_dest" ]; then
        if [ $force -eq 1 ]; then
            if command -v trash >/dev/null 2>&1; then
                trash "$dotfile_dest"
            else
                rm -rf "$dotfile_dest"
            fi
        else
            echo >&2 "Warning: $dotfile_dest already exists"
            read -r -n 1 -p "Replace $dotfile_dest? [Y|n] " will_continue
            printf "\n"
            case "$will_continue" in
                [yY]|"")
                    old="${dotfile_dest%/}.old"
                    rm -rf "$old"
                    mv "$dotfile_dest" "$old"
                    echo >&2 "Removed $dotfile_dest (backed up as $old)"
                    ;;
                *)
                    case "$will_continue" in
                        [nN])
                            ;;
                        *)
                            echo >&2 "Invalid input '$will_continue', not replacing"
                            ;;
                    esac
                    dotfile_dest="${dotfile_dest%/}.new"
                    win_dotfile_dest="${win_dotfile_dest%/}.new"
                    rm -rf "$dotfile_dest"
                    # Fall through to the default logic
                    ;;
            esac
        fi
    fi

    if [ $copy -eq 1 ]; then
        cp -R "$dotfile" "$dotfile_dest"
        echo >&2 "Copied $dotfile_dest"
    elif [ $wsl_winpath -eq 1 ]; then
        win_dotfile="$(wslpath -w "$dotfile")"
        case "$win_dotfile" in
            \\\\*)
                echo >&2 "Warning: $dotfile resides in a WSL path, copying rather than linking"
                echo >&2 "         Consider placing the dotfiles in a windows path."
                cp -R "$dotfile" "$dotfile_dest"
                echo >&2 "Copied $dotfile_dest"
                ;;
            *)
                if [ -d "$dotfile" ]; then
                    cmd.exe /c mklink /d "$win_dotfile_dest" "$win_dotfile"
                else
                    cmd.exe /c mklink "$win_dotfile_dest" "$win_dotfile"
                fi
                echo >&2 "Linked $(homepath "$win_dotfile_dest")"
                ;;
        esac
    else
        ln -s "$dotfile_relpath" "$dotfile_dest"
        echo >&2 "Linked $(homepath "$dotfile_dest")"
    fi
}

homepath () {
    echo "$@" | sed -e "s#^$HOME/#~/#" | if [ -n "$USERPROFILE" ]; then sed -e "s#^$USERPROFILE/#\$USERPROFILE/#"; else cat; fi
}

abspath () {
    # Return an absolute path for the specified argument
    _path="$1"
    if [ -n "${_path##/*}" ]; then
        _path="$(pwd -P)/$1"
    fi
    echo "$_path"
}

normalize_path()
{
    # Attempt to normalize the specified path, removing . and ..

    # Remove all /./ sequences.
    local path="${1//\/.\//\/}"

    # Remove dir/.. sequences.
    while [[ $path =~ ([^/][^/]*/\.\./) ]]
    do
        path="${path/${BASH_REMATCH[0]}/}"
    done
    echo "$path"
}

install_templated () {
    # Extremely basic template file generation, currently only implements
    # %include, which does what you would expect
    dotfile_dest="$2"
    destdir="${dotfile_dest%/*}"
    if [ "$destdir" != "$dotfile_dest" ]; then
        mkdir -p "$destdir"
    fi

    cat "$1" | while IFS='|' read line; do
        files=
        for prefix in $prefixes; do
            case "$line" in
                $prefix\ *)
                    files="${line#$prefix }"
                    ;;
            esac
        done

        if [ -z "$files" ]; then
            case "$line" in
                %include%*)
                    ;;
                *)
                    printf "%s\n" "$line"
                    ;;
            esac
            continue
        fi

        for file in $(echo $files); do
            cat "$file"
        done
    done >"$dotfile_dest"
    echo >&2 "Wrote $(abspath "$dotfile_dest")"
}

merge_to () {
    # Convenience wrapper for merging multiple files into one dotfile
    dotfile_dest="$1"
    destdir="${dotfile_dest%/*}"
    if [ "$destdir" != "$dotfile_dest" ]; then
        mkdir -p "$destdir"
    fi
    shift
    cat "$@" >$dotfile_dest
    echo >&2 "Wrote $(abspath "$dotfile_dest")"
}

usage () {
    printf "Usage: $0 [-f] [-x EXCLUDE_DIRS] [DOTFILE_HOME]\n"
    printf "\n"
    printf "DOTFILE_HOME defaults to \$HOME\n"
    printf "Options:\n"
    printf "  -f                Force install, overwriting any existing files\n"
    printf "  -x EXCLUDE_DIRS   Dotfile directories to exclude from the install\n"
    printf "  -i INCLUDE_DIRS   Additional dotfile directories to install\n"
    exit 1
}

while (( $# )); do
    case "$1" in
        -f)
            force=1
            ;;
        -x)
            shift || usage >&2
            exclude="$1"
            ;;
        -i)
            shift || usage >&2
            include="$1"
            ;;
        -*)
            usage >&2
            ;;
        *)
            break
            ;;
    esac
    shift
done


if [ $# -gt 0 ]; then
    DOTFILE_HOME="$(abspath "$1")"
else
    DOTFILE_HOME="${DOTFILE_HOME:-${HOME}}"
fi

dotfilesdir="$(abspath "${0%/*}")"
PATH="$dotfilesdir/scripts:$PATH"

export ASDF_DATA_DIR="${ASDF_DATA_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/asdf}"
export ASDF_CONFIG_FILE="${ASDF_CONFIG_FILE:-${XDG_CONFIG_HOME:-$HOME/.config}/asdfrc}"
export PYENV_ROOT="${PYENV_ROOT:-${XDG_DATA_HOME:-$HOME/.local/share}/pyenv}"
PATH="$(dirname "$0"):$ASDF_DATA_DIR/shims:$PYENV_ROOT/bin:$PYENV_ROOT/shims:$HOME/.local/bin:$PATH"

do_install () {
    installscript="$1"
    installscriptdir="$(cd "$(dirname "$installscript")" && pwd)"
    echo >&2 "Install $(relpath "$installscriptdir" "$dotfilesdir")"
    cd "${installscript%/*}"
    . "./${installscript##*/}"
    cd - >/dev/null
}


if [ -n "$exclude" ]; then
    echo >&2 "Excluded directories: $exclude"
fi

if [ -n "$include" ]; then
    echo >&2 "Additional directories to install: $include"
fi
mkdir -p "$XDG_DATA_HOME/../bin"

HOME="$DOTFILE_HOME"
for installscript in "$dotfilesdir/"*/install; do
    installdir="${installscript%/*}"
    if echo "$exclude" | grep -qw "${installdir##*/}"; then
        continue
    fi
    case "" in
        "/local")
            continue
            ;;
    esac

    do_install "$installscript"
done

for includepath in $include; do
    if [ -e "$include/install" ]; then
        do_install $include/install
    fi
done

if [ -e "/local/install" ]; then
    do_install "/local/install"
fi

exit 0

# vim: set sw=4 sts=4 ts=8 et:
