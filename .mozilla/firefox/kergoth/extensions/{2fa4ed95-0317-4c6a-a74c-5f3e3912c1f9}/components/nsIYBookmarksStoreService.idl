/*
 * Use this interface as a service.
*/
#include "nsISupports.idl"

interface nsIRDFDataSource;
interface nsIRDFResource;
interface nsIYBookmark;
interface nsIYBundle;
interface nsIMutableArray;
interface nsIPropertyBag;
interface nsIArray;

[scriptable, uuid(688130f9-6fdb-4b63-b934-68df1f6a9af2)]
interface nsIYBookmarksStoreService: nsISupports
{
  /** 
   * Flush the data to the storage files on the disk.
   * 
   * @param force force to write the data to the disk
   *
   */
  void flush(in boolean force);

  /**
   * @ return the Datasource that contains the primary bookmarks + tags data
   */
  nsIRDFDataSource getDataSource();
  
  /**
   * Add bookmark to the rdf datasource. Call Flush if shouldFlush parameter is set to true.
   * If bookmark already exists, do nothing.
   *
   * @param aUrl url of the bookmark. url cannot be changed once added
   * @param aTitle title of the bookmark
   * @param aCharset charset for the url
   * @param aIsWebPanel unknown. Just copied from the existing bookmark
   * @param aDescription short description for this bookmark
   * @param arraySize number of items in the next array parameter
   * @param aTags tags for this bookmark. Array of string
   * @param shared whether or not this bookmark is shared with public
   * @param localOnly whether or not this bookmark should be stored in local only
   * @param shouldFlush flag to indicate whether or not to call Flush after adding bookmark. 
   *       
   */
  void addBookmark(in wstring aUrl, 
                   in wstring aTitle,
                   in wstring aCharset,
                   in boolean aIsWebPanel, 
                   in wstring aDescription,
                   in wstring shortcutUrl,
                   in wstring postData,                   
                   in PRUint32 arraySize,
                   [ array, size_is(arraySize) ] in wstring aTags,
                   in wstring shared,
                   in wstring localOnly,                   
                   in boolean shouldFlush);

  /**
   * Add bookmark to rdf datasource. This method is same as the previous addBookmark method except
   * for the input parameter.
   *
   * @param bookmark bookmark object returned by getBookmark or newly created nsIYBookmark object
   * @param shouldFlush flag to indicate whether or not to call Flush after adding bookmark.
   * 
   */
  void addBookmarkObject(in nsIYBookmark bookmark, in boolean shouldFlush);

  /**
   * Add the tags to the given url. Does nothing if no url present in the bookmarks rdf database.
   * Duplicate tags are ignored.
   *
   * @param tagCount number of items in the next parameter, array of tags.
   * @param aTags array of tags. 
   * @param aUrl url to which aTags are applied.
   * @param shouldFlush flag to indicate whether or not to call Flush after tags are added.
   *
   * @return false if tags are applied successfully.
   *
   * NOTE: This method may throw an exception.
   *
   */
  boolean addTag(in PRUint32 tagCount, 
                 [array, size_is(tagCount)] in wstring aTags, 
                 in wstring aUrl, 
                 in boolean shouldFlush);

  /**
   * Add new livemarks to bookmarks datasource
   * @param aUrl the url of where the livemark comes from
   * @parma aTitle the title of the livemark
   * @param aFeedUrl the feed url
   * @param aDescription the description of the livemark
   * @param arraySize size of tags array
   * @param aTags array of tags
   * @param shared whether or not this bookmark is shared with public
   * @param localOnly whether or not this bookmark should be stored in local only   
   * @param shouldFlush should flush the livemarks datasource or not
   */
  void addLivemark(in wstring aUrl, 
                   in wstring aTitle, 
                   in wstring aFeedUrl, 
                   in wstring aDescription, 
                   in PRUint32 arraySize,
                   [ array, size_is(arraySize) ] in wstring aTags,
                   in wstring shared,
                   in wstring localOnly,                   
                   in boolean shouldFlush);

  /**
   * Delete all bookmarks 
   *
   * @param shouldFlush flag to indicate whether or not to call flush after removing all bookmarks
   */
  void deleteAllBookmarks(in boolean shouldFlush);

  /**
   * Edit the given bookmark. New values are provided as a nsIYBookmark object.
   * URL should not be allowed to be edited. Implementation is free to decide on 
   * the editable attributes.
   *
   * @param aUrl url to be edited.
   * @param args object of nsIYBookmark. This is key value pair represented as a JSON object.
   * 
   * @return false if aUrl is not present in the database, true otherwise.
   *
   * NOTE: Method may throw an exception.
   *
   */
  boolean editBookmark(in wstring aUrl, in nsIYBookmark args);

  /**
   * Delete the bookmark and all its associated tags from the database. If same tag is used by 
   * multiple bookmarks, only the association between bookmark and the tag is removed. Tag is 
   * retained in the system.
   *
   * @param aUrl url to be removed from the system.
   *
   * @return false if aUrl is not present in the system, true otherwise.
   *
   */
  boolean deleteBookmark( in wstring aUrl );

  /**
   * Get the bookmarks for a given tag. If aTag is null, return all the bookmarks.
   * 
   * @param aTag tag for which bookmark is requested.
   * @param aCount parameter which will be set to the number of items in the returned array.
   *
   * @return an array of nsIYBookmark object. Each object is a key value pair. An empty array if
   *         no urls tagged with the given tag or aTag is not present in the database.
   *
   */
  void getBookmarks(in wstring aTag, out PRUint32 aCount, [array, size_is(aCount), retval] out nsIYBookmark aArray); 

  /**
   * Get the tags for a given url. If url parameter is null, return all the tags in the system.
   *
   * @param aUrl url for which tags are requested.
   * @param aCount parameter which will be set to the number of items in the returned array.
   *
   * @return an array of string having the tags for the given aUrl. An empty array if aUrl is
   *         not present in the system or aUrl do not have any tags.
   *
   */
  void getTags(in wstring aUrl, out PRUint32 aCount, [array, size_is(aCount), retval] out wstring aArray); 


  /**
   * Whenever website is visited via the bookmark link the count on the bookmark is increased.
   * This also updates the last visited time.
   * 
   * @param aUrl url visited
   */
  void incrementVisitCount(in wstring aUrl);

  /**
   * Check if the given url is present in the bookmark database. 
   * 
   * @param aUrl url of the bookmark to be checked.
   * 
   * @return bookmark resource if present, null otherwise.
   *
   */
  nsIRDFResource isBookmarked(in wstring aUrl); 

  /* Check if the given feed url is present in the bookmark database. 
   * 
   * @param aFeedUrl url of the livemark to be checked.
   * 
   * @return bookmark resource if present, null otherwise.
   */
  nsIRDFResource isLivemarked(in wstring aFeedUrl);

  /* Reload the livemark
   * 
   * @param aFeedUrl url of the livemark to be reloaded.
   * 
   */
  void reloadLivemark(in wstring aFeedUrl);
 
  /**
   * Set the string value for the extra property for a url.
   * 
   * @param aUrl url of the bookmark to which key/value is to be applied.
   * @param aKey key of the extra property.
   * @param aValue string value of the property.
   *
   */
  void setBookmarkKeyAsString( in wstring aUrl, in wstring aKey, in wstring aValue );

  /**
   * Set the date/time value for the extra property for a url.
   * 
   * @param aUrl url of the bookmark to which key/value is to be applied.
   * @param aKey key of the extra property.
   * @param aValue unix timestamp value of the property.
   *
   */
  void setBookmarkKeyAsDate( in wstring aUrl, in wstring aKey, in unsigned long long aValue );

  /**
   * Set the integer value for the extra property for a url.
   * 
   * @param aUrl url of the bookmark to which key/value is to be applied.
   * @param aKey key of the extra property.
   * @param aValue integer value of the property.
   *
   */
  void setBookmarkKeyAsInt( in wstring aUrl, in wstring aKey, in short aValue );

  /**
   * Set the string value for the multiple properties. Use this when more than one property
   * value has to be set and all property values are string. 
   * keys and values array can have any number of elements, but must be atleast aCount number of
   * elements. Only aCount number of elements are used when setting the key/value pair.
   * Nth element from key is set to Nth element of values array.
   *
   * @param aUrl url of the bookmark to which key/value
   * @param aCount number of keys to be set
   * @param keys keys of the property to be set.
   * @param values values of the property to be set.
   */
  void setBookmarkKeysAsString(in wstring aUrl, in PRUint32 aCount, [array, size_is(aCount)] in wstring keys, [array, size_is(aCount)] in wstring values);

  /** 
   * Same as setBookmarkKeyAsString method except for data type of elements within values array are 
   * unix timestamp.
   *
   * @param aUrl url of the bookmark to which key/value
   * @param aCount number of keys to be set
   * @param keys keys of the property to be set.
   * @param values values of the property to be set.
   *
   */
  void setBookmarkKeysAsDate(in wstring aUrl, in PRUint32 aCount, [array, size_is(aCount)] in wstring keys, [array, size_is(aCount)] in unsigned long long values);

  /** 
   * Same as setBookmarkKeyAsString method except for data type of elements within values array are 
   * integers.
   *
   * @param aUrl url of the bookmark to which key/value
   * @param aCount number of keys to be set
   * @param keys keys of the property to be set.
   * @param values values of the property to be set.
   *
   */
  void setBookmarkKeysAsInt(in wstring aUrl, in PRUint32 aCount, [array, size_is(aCount)] in wstring keys, [array, size_is(aCount)] in short values);

  /**
   * Fetch the values for the keys set from setBookmarkKeyAsString or setBookmarkKeysAsString method.
   * 
   * @param aUrl url of the target bookmark.
   * @param inCount number of elements in keys array.
   * @param keys keys for which the values are requested.
   * @param outCount JSON object. value property of this object is set to the number of elements
   *                 in the output array. Output value is same as inCount.
   * 
   * @return array of string values. Each element in the array is the value of the corresponding key
   *         in the key array. values element is set to null, if corresponding key is not set for the
   *         aUrl.
   *
   */
  void getBookmarkStringValues(in wstring aUrl, in PRUint32 inCount, 
                               [array, size_is(inCount)] in wstring keys,
                               out PRUint32 outCount, 
                               [array, size_is(outCount), retval] out wstring values );

  /**
   * Fetch the values for the keys set from setBookmarkKeyAsInt or setBookmarkKeysAsInt method.
   * 
   * @param aUrl url of the target bookmark.
   * @param inCount number of elements in keys array.
   * @param keys keys for which the values are requested.
   * @param outCount JSON object. value property of this object is set to the number of elements
   *                 in the output array. Output value is same as inCount.
   * 
   * @return array of string values. Each element in the array is the value of the corresponding key
   *         in the key array. values element is set to 0, if corresponding key is not set for the
   *         aUrl.
   *
   */
  void getBookmarkIntValues(in wstring aUrl, in PRUint32 inCount, 
                            [array, size_is(inCount)] in wstring keys,
                            out PRUint32 outCount, 
                            [array, size_is(outCount), retval] out short values );
  /**
   * Fetch the values for the keys set from setBookmarkKeyAsDate or setBookmarkKeysAsDate method.
   * 
   * @param aUrl url of the target bookmark.
   * @param inCount number of elements in keys array.
   * @param keys keys for which the values are requested.
   * @param outCount JSON object. value property of this object is set to the number of elements
   *                 in the output array. Output value is same as inCount.
   * 
   * @return array of string values. Each element in the array is the value of the corresponding key
   *         in the key array. values element is set to 0, if corresponding key is not set for the
   *         aUrl.
   *
   */
  void getBookmarkDateValues(in wstring aUrl, in PRUint32 inCount, 
                             [array, size_is(inCount)] in wstring keys,
                              out PRUint32 outCount, 
                             [array, size_is(outCount), retval] out unsigned long long values );

  /**
   * The last update time is the timestamp provided by the service provider (example del.icio.us). 
   * This value is used to sync the local cache of the bookmarks with the server side bookmarks.
   * Instead of pulling all the bookmarks everytime, client can request for only the new/changed
   * bookmarks.
   *
   * @param timeString time stamp provided by the service provider.
   * 
   */
  void setLastUpdateTime(in wstring timeString);

  /**
   * Fetch the time stamp stored using setLastUpdateTime method.
   * 
   * @return the timestamp stored using setLastUpdateTime method.
   *
   */
  string getLastUpdateTime();

  /**
   * Return the bookmark properties given the url
   *
   * @param aUrl url for which properties are requested.
   *
   * @return nsIYBookmark object
   *
   */
  nsIYBookmark getBookmark(in wstring aUrl);

  /**
   * Fetch the bookmark given the bookmark resource object. 
   * 
   * @param aBookmarkResource bookmark resource reference
   * 
   * @return nsIYBookmark object having the details about the current bookmark.
   */
  nsIYBookmark getBookmarkFromResource( in nsIRDFResource aBookmarkResource );
  
  /**
   * @return  datasource which would be used to hold the search results
   */
  nsIRDFDataSource getSearchDataSource();

  /**
   * Search tags and set the results in the search datasource (NC:YBSearch)
   * @param aKeyword keyowrd to be searched
   * @return number of results
   */
  PRUint32 search(in wstring aKeyword, in PRUint32 aStoreNumber);

  /**
   * Search tag folders and add them to the datasource (NC:YBTagsSearch + aStoreNumber) 
   * if their name contains the keyword
   *
   * @param aKeyword keyword to be searched
   * @param aStoreNumber number to identify the store e.g 1 for sidebar,  2 for popup   
   * @return number of results   
   */
  PRUint32 searchTags(in wstring aKeyword, in PRUint32 aStoreNumber);

  /**
   * Search bookmarks and add them to the search datasource (NC:YBBookmarksSearch + aStoreNumner)
   * if their name, url or tags contains the keyword
   *
   * @param aKeyword keyword to be searched
   * @param aStoreNumber number to identify the store e.g 1 for sidebar,  2 for popup
   * @return number of results
   */
  PRUint32 searchBookmarks(in wstring aKeyword, in PRUint32 aStoreNumber);

  void getTagsSearchResults(in PRUint32 aStoreNumber, out PRUint32 aCount, [array, size_is(aCount), retval] out wstring aArray); 
  void getBookmarksSearchResults(in PRUint32 aStoreNumber, out PRUint32 aCount, [array, size_is(aCount), retval] out nsIRDFResource aArray); 

  /**
   * Returned tag resource name can be used in the ref attribute of the template in XUL.
   *
   * @param aTag tag for which tag resource name is requested
   *
   * @return the resource name used (anonymous) for the tag in the local store.
   */
  string getTagResourceName(in wstring aTag);
  
  /**
   *  Get the type of a resource
   *
   *  @param aResource a bookmark resource
   *
   *  @return string the type of the resource
   */
  string resolveBookmarkResourceType(in nsIRDFResource aResource);

  /**
   *  Add a transaction (e.g. add, edit and delete bookmark) to the datasource
   *  
   *  @param aType the type of the transaction
   *  @param aState the state of the transaction   i.e. 0 - uninitialized, 1= sent, 2 = completed
   *  @param aJSON the object which contains the bookmark's information
   *
   */
  void addTransaction (in string aType, in PRUint32 aState, in nsISupports aJSON);
    
  /**
   *  Remove a transaction from the datasource
   *  
   *  @param aType the type of the transaction
   *  @param aUrl the bookmark url
   *
   */
  void removeTransaction (in string aType, in wstring aUrl);

  /**
   *  Remove all transactions in particular state.
   *  
   *  @param aState the state of the transactions. i.e. 0 - uninitialized, 1 - sent, 2 - completed, 3 - failed, 10 - all
   */ 
  void removeAllTransactions (in PRUint32 aState);
  
  /**
   *  Set the state of a transaction
   *   
   *  @param aType the type of the transaction
   *  @param aUrl the bookmark url
   *  @param aState the state of the transactions. i.e. 0 - uninitialized, 1 - sent, 2 - completed, 3 - failed
   *
   */ 
  void setTransactionState (in string aType, in wstring aUrl, in PRUint32 aState);
  
  /**
   *  Get all transactions from the datasource
   *  
   *  @return the MutableArray contains all transactions 
   *  and each of them is in hashPropertyBag format 
   *
   */ 
  nsIMutableArray getTransactions ();

  /**
   *  Reset the 'sent' and 'failed' transactions to 'uninitialized'
   *  after a period of time
   *
   */
  void restateTransactions ();
  
  /**
   *  Get all bookmarks' metahash and urlhash from the datasource
   *  
   *  @return the MutableArray contains all transactions 
   *  and each of them is in hashPropertyBag format 
   *
   */   
  nsIMutableArray getBookmarkHashes ();  
  
  
  /**
   * Delete the bookmark and all its associated tags from the database. If same tag is used by 
   * multiple bookmarks, only the association between bookmark and the tag is removed. Tag is 
   * retained in the system.
   *
   * @param aHash boookmark which contain this url hash would be removed from the system.
   *
   * @return false if url hash is not present in the system, true otherwise.
   *
   */
  boolean deleteBookmarkForHash ( in wstring aHash );

  /**
   *  Get the number of transactions in the datasource
   *  
   *  @param aType the type of the transaction. i.e. addBookmark, editBookmark, deleteBookmark, all/""
   *  @param aState the state of the transactions. i.e. 0 - uninitialized, 1 - sent, 2 - completed, 3 - failed
   *
   *  @return number the number of transactions
   *
   */ 
  PRUint32 getNumberOfTransactions (in string aType, in PRUint32 aState);

  /*
   * Get the tags suggestion based on the keyword input
   *
   * @param aKeyword keyword input
   * 
   */  
  nsIMutableArray getTagSuggestions (in wstring aKeyword);
  
  /**
   * Return the total number of bookmarks in the store
   *
   * @return total number of bookmarks
   */
  PRUint32 getTotalBookmarks();

  /**
   * Returns total number of tags in the system
   * 
   * @return total number of tags
   */
  PRUint32 getTotalTags();

  /**
   * Returns total number of bookmarks for a tag
   * 
   * @return total number of bookmarks
   */
  PRUint32 getTotalBookmarksForTag(in wstring aTag);
          
    /**
        * Get an array of all the Favorite Tags
        *
        * @return an array of strings with the Favorite Tag names in order
        */
    void getFavoriteTags (out PRUint32 aCount, [array, size_is(aCount), retval] out wstring aArray);
    
    /**
        * Add a Favorite Tag to the datastore
        */
    void addFavoriteTag (in wstring aTag);
    
    /**
        * Removes a Favorite Tag from the datastore
        */
    void deleteFavoriteTag (in wstring aTag);
    
    /**
        * Moves a pre-existing Favorite Tag to a particular index.  Datastore indexes are 1 based.
        */
    void moveFavoriteTag (in wstring aTag, in PRUint32 aIndex);
    
    /**
        * Removes all the Favorite Tags
        */
    void clearFavoriteTags();
    
        /**
        * Cleans out the Favorite Tags' bookmarks resources, but does not delete them.  Maintains the preferred order
        */   
        void cleanOutFavoriteTags();
    
        /**
        * Return the bookmarks for a favorite tag in order.
        *
        * @return array of nsIYbookmark
        */
    void getBookmarksFromFavoriteTag (in wstring aTag, out PRUint32 aCount, [array, size_is(aCount), retval] out nsIYBookmark aArray);
    
    /**
        * Get the display order preference for a Favorite Tag (i.e chrono, user-specified, alpha-numerical, etc)
        *
        * @return string
        */
    string getFavoriteTagOrder(in wstring aTag);
    
    /**
        * Set the display order for the bookmarks of a favorite tag.  This doesn't actually change the order in the datasource 
        * (the order in the datasrouce is always stored in "user-specified" order), it merely 
        * sets a field to the order.
        */
    void setFavoriteTagOrder(in wstring aTag, in wstring aOrder);
    
    /**
        * Returns whether aTag is a Favrite Tag
        *
        * @return nsIRDFResource or null
        */
    nsIRDFResource isFavoriteTag(in wstring aTag);
    
    /**
      * Retrieves all the bookmarks for a Livemark
      *
      * @return an array of nsIYBookmark
      */
    void getBookmarksForLivemark (in wstring aUrl, out PRUint32 aCount, [array, size_is(aCount), retval] out nsIYBookmark aArray);
    
		/**
			* Return an array of Bundles
			*/
    void getBundles(out PRUint32 aCount, [array, size_is(aCount), retval] out nsIYBundle aArray);

		/**
			* Return the Bundle for a given bundle name
			*/
    nsIYBundle getBundle(in wstring aBundle);

		/**
			* Adds the the argument bundles to the current set of bundles.  Note that any pre-existing bundles will remain.
			*/
    void setBundles(in nsIArray aBundles);
    
		/**
			* Clears out the Bundles
			*/
    void clearBundles();
    
    void setBundle(in nsIYBundle aBundle);
    
    void deleteBundle(in wstring aBundle);
    
    /**
    * Moves a pre-existing Bundle to a particular index.  Datastore indexes are 1 based.
    */
    void moveBundle (in wstring aBundle, in PRUint32 aIndex);
};
