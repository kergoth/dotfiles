function DownloadInfoBroadcast() {
// you can do |this.wrappedJSObject = this;| for the first version of the component
// (in case you don't want to write IDL yet.)
this.wrappedJSObject = this;
}
DownloadInfoBroadcast.prototype = {
  classID: Components.ID("{764F23A5-6594-485b-8E9B-87C8C8A15E57}"),
  contractID: "@devonjensen.com/downbar/downloadBroadcast;1",
  classDescription: "Accept all download progress updates and broadcast them to download statusbar and download manager",

  QueryInterface: function(aIID) {
    if(!aIID.equals(CI.nsISupports) && !aIID.equals(CI.nsIObserver) && !aIID.equals(CI.nsISupportsWeakReference)) // you can claim you implement more interfaces here
      throw CR.NS_ERROR_NO_INTERFACE;
    return this;
  },

  // nsIObserver implementation
  observe: function(aSubject, aTopic, aData) {
  	
  	//var acs = Components.classes["@mozilla.org/consoleservice;1"].getService(Components.interfaces.nsIConsoleService);
	//acs.logStringMessage(aTopic);
  	
    switch(aTopic) {
      case "xpcom-startup":
        //dump("xpcom-startup");
        // this is run very early, right after XPCOM is initialized, but before
        // user profile information is applied. Register ourselves as an observer
        // for 'profile-after-change' and 'quit-application'.
        var obsSvc = CC["@mozilla.org/observer-service;1"].getService(CI.nsIObserverService);
        obsSvc.addObserver(this, "profile-after-change", true);
        obsSvc.addObserver(this, "quit-application", true);
        break;

      case "profile-after-change":
        // This happens after profile has been loaded and user preferences have been read.
        // startup code here
        this.takeListener();
        
        break;

      case "quit-application":
        dump("quit");
        // shutdown code here
        
        const db_dlmgrContractID = "@mozilla.org/download-manager;1";
		const db_dlmgrIID = Components.interfaces.nsIDownloadManager;
		db_gDownloadManager = Components.classes[db_dlmgrContractID].getService(db_dlmgrIID);
   		db_gDownloadManager.listener = null;
        
        break;

      default:
        throw Components.Exception("Unknown topic: " + aTopic);
    }
  },
  
  // This collects raw download data
  onProgressChange : function(aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, 
							aCurTotalProgress, aMaxTotalProgress, aDownload) {
		try {
			var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"].getService(Components.interfaces.nsIWindowMediator);
			var e = wm.getEnumerator("navigator:browser");
			var win;
		
			while (e.hasMoreElements()) {
				win = e.getNext();
				// Send info to download statusbar in each window
				win.db_progressUpdate(aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, 
							aCurTotalProgress, aMaxTotalProgress, aDownload);
				
				//win.alert('test');
				//var acs = Components.classes["@mozilla.org/consoleservice;1"].getService(Components.interfaces.nsIConsoleService);
				//acs.logStringMessage('inprogresschange');
			}
			
			// Send info to download manager window if open
			var dlwin = wm.getMostRecentWindow("Download:Manager");
			if(dlwin) {
				dlwin.gDownloadListener.onProgressChange(aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, 
							aCurTotalProgress, aMaxTotalProgress, aDownload);
				
			}
			else {}
				
			
		} catch (e){}
  },
  onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus, aDownload) {
  	var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"].getService(Components.interfaces.nsIWindowMediator);
	var dlwin = wm.getMostRecentWindow("Download:Manager");
	if(dlwin) {
		dlwin.gDownloadListener.onStateChange(aWebProgress, aRequest, aStateFlags, aStatus, aDownload);		
	}
  
  },
  // These aren't used by download manager or download statusbar
  onLocationChange : function(aWebProgress, aRequest, aLocation) {},
  onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage) {},
  onSecurityChange : function(aWebProgress, aRequest, aState) {},
  
  
  takeListener : function() {
  	const db_dlmgrContractID = "@mozilla.org/download-manager;1";
	const db_dlmgrIID = Components.interfaces.nsIDownloadManager;
	db_gDownloadManager = Components.classes[db_dlmgrContractID].getService(db_dlmgrIID);
    db_gDownloadManager.listener = this;
  	
  },
  
  
};


// constructors for objects we want to XPCOMify
var objects = [DownloadInfoBroadcast];

/*
 * Registration code.
 *
 */

const CI = Components.interfaces, CC = Components.classes, CR = Components.results;

const MY_OBSERVER_NAME = "DownBroadcast Observer";

function FactoryHolder(aObj) {
  this.CID        = aObj.prototype.classID;
  this.contractID = aObj.prototype.contractID;
  this.className  = aObj.prototype.classDescription;
  this.factory = {
    createInstance: function(aOuter, aIID) {
      if(aOuter)
        throw CR.NS_ERROR_NO_AGGREGATION;
      return (new this.constructor).QueryInterface(aIID);
    }
  };
  this.factory.constructor = aObj;
}

var gModule = {
  registerSelf: function (aComponentManager, aFileSpec, aLocation, aType)
  {
    aComponentManager.QueryInterface(CI.nsIComponentRegistrar);
    for (var key in this._objects) {
      var obj = this._objects[key];
      aComponentManager.registerFactoryLocation(obj.CID, obj.className,
        obj.contractID, aFileSpec, aLocation, aType);
    }

    // this can be deleted if you don't need to init on startup
    var catman = CC["@mozilla.org/categorymanager;1"].getService(CI.nsICategoryManager);
    catman.addCategoryEntry("xpcom-startup", MY_OBSERVER_NAME,
      DownloadInfoBroadcast.prototype.contractID, true, true);
    catman.addCategoryEntry("xpcom-shutdown", MY_OBSERVER_NAME,
      DownloadInfoBroadcast.prototype.contractID, true, true);
  },

  unregisterSelf: function(aCompMgr, aFileSpec, aLocation) {
    // this must be deleted if you delete the above code dealing with |catman|
    var catman = CC["@mozilla.org/categorymanager;1"].getService(CI.nsICategoryManager);
    catman.deleteCategoryEntry("xpcom-startup", MY_OBSERVER_NAME, true);
    // end of deleteable code

    aComponentManager.QueryInterface(CI.nsIComponentRegistrar);
    for (var key in this._objects) {
      var obj = this._objects[key];
      aComponentManager.unregisterFactoryLocation(obj.CID, aFileSpec);
    }
  },

  getClassObject: function(aComponentManager, aCID, aIID) {
    if (!aIID.equals(CI.nsIFactory)) throw CR.NS_ERROR_NOT_IMPLEMENTED;

    for (var key in this._objects) {
      if (aCID.equals(this._objects[key].CID))
        return this._objects[key].factory;
    }
   
    throw CR.NS_ERROR_NO_INTERFACE;
  },

  canUnload: function(aComponentManager) {
    return true;
  },

  _objects: {} //FactoryHolder
};

function NSGetModule(compMgr, fileSpec)
{
  for(var i in objects)
    gModule._objects[i] = new FactoryHolder(objects[i]);
  return gModule;
} 