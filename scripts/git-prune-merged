#!/bin/bash

usage () {
    echo >&2 "${0##*/} [-r REMOTE] [-R] [UPSTREAM_BRANCH]"
    echo >&2
    echo >&2 "Delete branches which have been fully merged."
    echo >&2
    echo >&2 "Options:"
    echo >&2
    echo >&2 "  UPSTREAM_BRANCH     Specify the base upstream branch where the"
    echo >&2 "                      changes are merged, defaults to origin/master."
    echo >&2 "  -r REMOTE   Prune branches of the specified remote, not local."
    echo >&2 "  -R          Prune the branches in the repo repo, not just the tracking branches."
    echo >&2 "  -c CORRESPONDING_REMOTE  Delete branches which have been merged to the branch of"
    echo >&2 "                           the same name in CORRESPONDING_REMOTE, not to UPSTREAM_BRANCH."
    echo >&2 "  -n          Dry-run"
    exit 2
}

ref_prefix=refs/heads
prune_remote_repo=0
dry_run=0
corresponding=
while getopts r:Rc:nh opt; do
    case "$opt" in
        r)
            ref_prefix="refs/remotes/$OPTARG"
            ;;
        R)
            prune_remote_repo=1
            ;;
        n)
            dry_run=1
            ;;
        c)
            corresponding="$OPTARG"
            ;;
        \?|h)
            usage
            ;;
    esac
done
shift $((OPTIND - 1))

if [ $dry_run -eq 1 ]; then
    alias git="echo git"
fi

if [ -n "$corresponding" ] && [ $# -gt 0 ]; then
    echo >&2 "Error: -c and UPSTREAM_BRANCH arguments conflict"
    exit 1
fi

upstream_branch="${1:-origin/master}"

command git for-each-ref "${corresponding:---merged=$upstream_branch}" --format='%(refname)' "$ref_prefix" | \
    while read -r ref; do
        ref="${ref#$ref_prefix/}"

        if [ -n "$corresponding" ]; then
            upstream_ref="$corresponding/$ref"
            if ! git rev-parse --quiet --verify "refs/remotes/$upstream_ref" >/dev/null; then
                # No corresponding branch upstream
                continue
            else
                resolved="$(git rev-parse "$ref_prefix/$ref")"
                if [ "$(git merge-base "refs/remotes/$upstream_ref" "$ref_prefix/$ref")" != "$resolved" ]; then
                    # Not merged into corresponding branch upstream
                    continue
                fi
            fi
        fi

        case "$ref_prefix" in
            refs/heads)
                remote="$(git config "branch.$ref.pushremote" 2>/dev/null || git config "branch.$ref.remote")"
                git branch -d "$ref"
                if [ $prune_remote_repo -eq 1 ] && git rev-parse --quiet --verify "refs/remotes/$remote/$ref"; then
                    git push "$remote" ":$ref"
                fi
                ;;
            refs/remotes/*)
                remote="${ref_prefix#refs/remotes/}"
                if [ $prune_remote_repo -eq 1 ]; then
                    git push "$remote" ":$ref"
                else
                    git branch -r -d "${ref_prefix#refs/remotes/}/$ref"
                fi
                ;;
        esac
    done
