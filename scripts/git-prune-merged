#!/bin/sh

usage () {
    echo >&2 "${0##*/} [-r REMOTE] [-R] [UPSTREAM_BRANCH]"
    echo >&2
    echo >&2 "Delete branches which have been fully merged."
    echo >&2
    echo >&2 "Options:"
    echo >&2
    echo >&2 "  UPSTREAM_BRANCH     Specify the base upstream branch where the"
    echo >&2 "                      changes are merged, defaults to origin/master."
    echo >&2 "  -r REMOTE   Prune branches of the specified remote, not local."
    echo >&2 "  -R          Prune the branches in the repo repo, not just the tracking branches."
    echo >&2 "  -n          Dry-run"
    exit 2
}

ref_prefix=refs/heads
prune_remote_repo=0
dry_run=0
while getopts r:Rnh opt; do
    case "$opt" in
        r)
            ref_prefix="refs/remotes/$OPTARG"
            ;;
        R)
            prune_remote_repo=1
            ;;
        n)
            dry_run=1
            ;;
        \?|h)
            usage
            ;;
    esac
done
shift $((OPTIND - 1))

if [ $dry_run -eq 1 ]; then
    alias git="echo git"
fi

command git for-each-ref "--merged=${1:-origin/master}" --format='%(refname)' "$ref_prefix" | \
    while read -r ref; do
        ref="${ref#$ref_prefix/}"
        case "$ref" in
            master|HEAD)
                continue
                ;;
        esac

        case "$ref_prefix" in
            refs/heads)
                remote="$(git config "branch.$ref.pushremote" 2>/dev/null || git config "branch.$ref.remote")"
                git branch -d "$ref"
                if [ $prune_remote_repo -eq 1 ] && git rev-parse --quiet --verify "refs/remotes/$remote/$ref"; then
                    git push "$remote" ":$ref"
                fi
                ;;
            refs/remotes/*)
                remote="${ref_prefix#refs/remotes/}"
                if [ $prune_remote_repo -eq 1 ]; then
                    git push "$remote" ":$ref"
                else
                    git branch -r -d "${ref_prefix#refs/remotes/}/$ref"
                fi
                ;;
        esac
    done
