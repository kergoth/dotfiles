#!/usr/bin/env python3
# TODO: by default, keep refs which don't belong to any remote, as they can't
# be restored with git fetch. add a new argument to force their removal unless
# specified with -r.
#   If any remotes are marked as mirror=true, or have +refs/*:refs/*, there are
#   no local refs to keep, otherwise grab all refs other than refs/remotes/*.
# TODO: complete sane handling of reflogs. Possibly add multiple arguments,
# keep only HEAD reflog, keep all local relogs, keep all non-tag reflogs, keep
# all reflogs
# TODO: should detaching from alternates be optional instead of automatic?
# The repo can be shallow with or without alternates, it's just that it makes
# git fsck show a lot of unreachable objects.
# TODO: avoid corrupting or disrupting repository state when interrupted

"""git-make-shallow: make the current git repository shallow."""

import argparse
import collections
import errno
import itertools
import os
import subprocess
import sys

version = 0.9


def main():
    parser = argparse.ArgumentParser(description='Make the current git repository shallow, removing the history of the specified revisions')
    parser.add_argument('--ref', '-r', metavar='REF', action='append', dest='refs', help='remove all but the specified refs (cumulative)')
    parser.add_argument('revisions', metavar='REVISION', nargs='+', help='a git revision/commit')
    if len(sys.argv) < 2:
        parser.print_help()
        sys.exit(2)

    if sys.version_info < (3, 4, 0):
        sys.exit('Python 3.4 or greater is required')

    args = parser.parse_args()
    make_shallow(args.revisions, args.refs)


def check_output(cmd, input=None):
    return subprocess.check_output(cmd, universal_newlines=True, input=input)

def make_shallow(revisions, refs):
    """Make the current git repository shallow at the specified revisions, given the specified refs."""
    if refs is None:
        refs = get_all_refs(lambda p: not p[1] or p[1] == 'commit')
    else:
        refs = check_output(['git', 'rev-parse', '--symbolic-full-name'] + refs).splitlines()

    git_dir = check_output(['git', 'rev-parse', '--git-dir']).rstrip()
    shallow_file = os.path.join(git_dir, 'shallow')
    try:
        os.unlink(shallow_file)
    except OSError as exc:
        if exc.errno != errno.ENOENT:
            raise

    parsed_revs = check_output(['git', 'rev-parse'] + ['%s^{}' % i for i in revisions]).splitlines()
    for rev in follow_history_intersections(parsed_revs, refs):
        print("Processing %s" % rev)
        with open(shallow_file, 'a') as f:
            f.write(rev + '\n')

    filter_refs(refs)
    shrink_repo()
    subprocess.check_call(['git', 'fsck', '--unreachable'])


def get_all_refs(ref_filter=None):
    """Return all the existing refs in this repository, optionally filtering the refs."""
    ref_output = check_output(['git', 'for-each-ref', '--format=%(refname)	%(*objecttype)'])
    ref_split = [tuple(iter_extend(l.rstrip().rsplit('\t', 1), 2)) for l in ref_output.splitlines()]
    if ref_filter:
        ref_split = (e for e in ref_split if ref_filter(e))
    refs = [r for r, _ in ref_split]
    return refs


def iter_extend(iterable, length, obj=None):
    """Ensure that iterable is the specified length by extending with obj."""
    return itertools.islice(itertools.chain(iterable, itertools.repeat(obj)), length)


def filter_refs(refs):
    """Remove all but the specified refs from the git repository."""
    all_refs = get_all_refs()
    full_refs = check_output(['git', 'rev-parse', '--symbolic-full-name'] + refs).splitlines()
    to_remove = set(all_refs) - set(full_refs)
    if to_remove:
        check_output(['xargs', '-0', '-n', '1', 'git', 'update-ref', '-d', '--no-deref'],
                     input=''.join(l + '\0' for l in to_remove))


def follow_history_intersections(revisions, refs):
    """Determine all the points where the history of the specified revisions intersects the specified refs."""
    queue = collections.deque(revisions)
    seen = set()

    for rev in iter_except(queue.popleft, IndexError):
        if rev in seen:
            continue

        parent_output = check_output(['git', 'rev-parse', '%s^@' % rev])
        parents = [p.rstrip() for p in parent_output.splitlines()]

        yield rev
        seen.add(rev)

        if not parents:
            continue

        check_refs = check_output(['git', 'merge-base', '--independent'] + sorted(refs)).splitlines()
        for parent in parents:
            for ref in check_refs:
                print("Checking %s vs %s" % (parent, ref))
                try:
                    merge_base = check_output(['git', 'merge-base', parent, ref]).rstrip()
                except subprocess.CalledProcessError:
                    continue
                else:
                    queue.append(merge_base)


def iter_except(func, exception, start=None):
    """Yield a function repeatedly until it raises an exception."""
    try:
        if start is not None:
            yield start()
        while True:
            yield func()
    except exception:
        pass


def shrink_repo():
    """Shrink the newly shallow repository, removing the unreachable objects."""
    subprocess.check_call(['git', 'reflog', 'expire', '--expire-unreachable=now', '--all'])
    subprocess.check_call(['git', 'repack', '-ad'])
    git_dir = check_output(['git', 'rev-parse', '--git-dir']).rstrip()
    try:
        os.unlink(os.path.join(git_dir, 'objects', 'info', 'alternates'))
    except OSError as exc:
        if exc.errno != errno.ENOENT:
            raise
    subprocess.check_call(['git', 'prune', '--expire', 'now'])


if __name__ == '__main__':
    main()
